<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyseur Probabiliste du Loto</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    
    <style>
        
              
  
       /* ============================================================================
           RESET ET VARIABLES
        ============================================================================ */
         :root {
              --primary-color: #343a40;
            --secondary-color: #343a40
            --accent-color: #6c757d;
            --highlight-color: rgba(15, 52, 96, 0.3);
            --text-primary: #f0f0f0;
            --text-secondary: #f0f0f0;
            --border-color: rgba(255, 255, 255, 0.1);
            --card-bg: ; #6c757d;
            --sidebar-width: 240px;
            --header-height: 86px;
            
        --glass-bg: rgba(255, 255, 255, 0.1);
    --glass-border: rgba(255, 255, 255, 0.2);
    --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
    --glass-blur: blur(10px);
}
        
        .glass-effect {
    background: var(--glass-bg);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 1px solid var(--glass-border);
    box-shadow: var(--glass-shadow);
}

.glass-card {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.1) 0%, 
        rgba(255, 255, 255, 0.05) 100%);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 8px;
    box-shadow: 
       
}

.latest-draw.glass-card {
    padding: 20px !important;
}

.glass-nav {
    background: rgba(108, 117, 125, 0.7) !important;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(10px);
    border-right: 1px solid rgba(255, 255, 255, 0.1);
}
        
        /* Sidebar avec effet glass */
.sidebar {
    
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(10px);
    border-right: 1px solid rgba(255, 255, 255, 0.15);
}

/* Header glass */
.header {
   
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

/* Cartes de contenu */
.section, .control-group, .stat-card, .info-box {
    background: linear-gradient(1deg, 
        rgba(255, 255, 255, 0.08) 0%, 
        rgba(255, 255, 255, 0.03) 100%) !important;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.1),
       
}

/* Boutons glass */
button, .copy-btn {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.15) 0%, 
        rgba(255, 255, 255, 0.05) 100%) !important;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    border-radius: 8px;
    transition: all 0.3s ease;
}

button:hover, .copy-btn:hover {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.25) 0%, 
        rgba(255, 255, 255, 0.15) 100%) !important;
    border-color: rgba(255, 255, 255, 0.3) !important;
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
}
         
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--primary-color);
            color: var(--text-primary);
            line-height: 1.1;
            min-height: 100vh;
            display: flex;
        }
        
        /* ============================================================================
   AJUSTEMENTS DES TAILLES DE POLICE PAR ONGLET
============================================================================ */

/* Onglet Accueil */
        
#overview .section h2 {
    font-size: 1.7rem;
}

#overview .section p {
    font-size: 1.05rem;
}

#overview .stat-card .value {
    font-size: 1.1rem;
}

#overview .info-box li {
    font-size: 0.92rem;
}

/* Onglet Fréquences */
        
#frequencies .section h2 {
    font-size: 1.7rem;
}

#frequencies .section p {
    font-size: 1.15rem;
}

#frequencies .info-box p {
    font-size: 1rem;
}

/* Onglet Probabilités */
        
#predictions .section h2 {
    font-size: 1.7rem;
}

#predictions .section p {
    font-size: 1.05rem;
}

#predictions .info-box p {
    font-size: 1rem;
}

#predictionExplanations {
    font-size: 0.95rem;
}

/* Onglet Machine Learning */
        
#ml .section h2 {
    font-size: 1.7rem;
}

#ml .section p {
    font-size: 1.05rem;
}

#ml .info-box p {
    font-size: 0.95rem;
}

#mlExplanationContent p {
    font-size: 0.95rem;
}

/* Onglet Clustering */
        
#clusters .section h2 {
    font-size: 1.7rem;
}

#clusters .section p {
    font-size: 1.05rem;
}

#clusters .info-box p {
    font-size: 0.95rem;
}

/* Onglet Statistiques */
        
#statistics .section h2 {
    font-size: 1.7rem;
}

#statistics .section p {
    font-size: 1.05rem;
}

#statistics .info-box p {
    font-size: 0.95rem;
}

/* Onglet Évaluation */
        
#evaluation .section h2 {
    font-size: 1.7rem;
}

#evaluation .section p {
    font-size: 1.05rem;
}

#evaluation .info-box p {
    font-size: 0.95rem;
}

#evaluation .grid-title {
    font-size: 1.1rem;
}

/* Onglet Simulation */
        
#simulation .section h2 {
    font-size: 1.7rem;
}

#simulation .section p {
    font-size: 1.05rem;
}

#simulation .info-box p {
    font-size: 0.95rem;
}

#simulation .grid-title {
    font-size: 1.1rem;
}

/* Onglet Programme */
        
#programme .section h2 {
    font-size: 1.7rem;
}

#programme .section p {
    font-size: 1.05rem;
}

#programme .info-box p {
    font-size: 0.95rem;
}

#programme h3 {
    font-size: 1.4rem;
}
        
/* Styles pour les explications ML détaillées */
        
.ml-explanation-steps {
    line-height: 1.2;
}

.ml-explanation-steps ol {
    margin-left: 20px;
    margin-bottom: 1px;
}

.ml-explanation-steps li {
    margin-bottom: 5px;
}

.ml-explanation-steps ul {
    margin-left: 15px;
    margin-top: 5px;
    margin-bottom: 10px;
}

.ml-explanation-steps strong {
    color: var(white);
}

.ml-explanation-steps h5 {
    color: var(--accent-color);
    margin-bottom: 15px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
}

/* Ajustements généraux supplémentaires */

button, input, select {
    font-size: 0.95rem;
}

.stat-card h4 {
    font-size: 0.95rem;
}

.number-ball, .number-ball-select, .number-ball-chance-select {
    font-size: 0.95rem;
}

        /* ============================================================================
           STRUCTURE PRINCIPALE
        ============================================================================ */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--secondary-color);
            border-right: 1px solid var(--border-color);
            height: 100vh;
            position: fixed;
            overflow-y: auto;
            z-index: 100;
        }

        .main-content {
            margin-left: var(--sidebar-width);
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            max-width: 1400px;
        }

        .header {
            height: var(--header-height);
            background-color: var(--secondary-color);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 23px;
            position: sticky;
            top: 0;
            z-index: 90;
        }

        .content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }

        /* ============================================================================
           SIDEBAR STYLES
        ============================================================================ */
        
        .logo {
            padding: 17px;
            border-bottom: 0px solid var(--border-color);
            text-align: center;
        }

        .logo h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .logo p {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .nav-menu {
            padding: px 0;
        }

        .nav-item {
    display: flex;
    align-items: center;
    padding: 10px 10px;
    color: var(--text-secondary);
    text-decoration: none;
    transition: all 0.3s ease;
    border-left: 3px solid transparent;
    cursor: pointer;
    margin: 5px 15px;
    border-radius: 6px;
    background: linear-gradient(deg, 
        rgba(255, 255, 255, 0.1) 0%, 
        rgba(255, 255, 255, 0.05) 100%);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
}
        .nav-item:hover {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.15) 0%, 
        rgba(255, 255, 255, 0.08) 100%);
    color: var(--text-primary);
    border-color: rgba(255, 255, 255, 0.2);
    transform: translateX(5px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}
        .nav-item.active {
            background-color: rgba(255, 255, 255, 0.04);
            color: var(--text-primary);
            border-left-color: var(--highlight-color);
        }

        .nav-item i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

.nav-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg,
        transparent,
        rgba(255, 255, 255, 0.1),
        transparent);
    transition: left 0.5s ease;
}

        /* ============================================================================
           CONTENU PRINCIPAL
        ============================================================================ */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .section {
            background-color: var(--card-bg);
            border: 0px solid var(--border-color);
            margin-bottom: 20px;
            padding: 20px;
        }

        .section h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--text-primary);
            font-weight: 400;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .section h3 {
            font-size: 1.2rem;
            margin: 15px 0 px 0;
            color: var(--text-primary);
            font-weight: 400;
        }

        /* ============================================================================
           BARREGRAPHE HORIZONTAL
        ============================================================================ */

        .loading {
            display: none;
            text-align: center;
            padding: 1px 1px;
            color: var(--text-secondary);
        }

        .loading.active {
            display: block;
        }

        .progress-container {
            width: 100%;
            max-width: 500px;
            margin: 20px auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .progress-bar {
            height: 12px;
            background: linear-gradient(90deg, 
                #1976d2 0%, 
                #66bb6a 50%, 
             #388e3c 100%);
            border-radius: 8px;
            width: 0%;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        /* Effet de brillance animé */
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.4) 50%,
                transparent 100%);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            0% { left: -100%; }
            100% { left: 200%; }
        }

        .progress-text {
            margin-top: 15px;
            font-size: 1.1em;
            font-weight: 500;
            color: var(--text-primary);
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .progress-percentage {
            font-weight: bold;
            color: #667eea;
            font-size: 1.2em;
        }

        /* Animation de pulsation pour le texte */
        @keyframes pulseText {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-text {
            animation: pulseText 2s infinite;
        }

        /* ============================================================================
           COMPOSANTS DE FORMULAIRE
        ============================================================================ */
        .control-group {
            margin: 20px 0;
            padding: 20px;
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
        }

        .control-group label {
            font-size: 1rem;
            display: block;
            margin-bottom: 8px;
            font-weight: 400;
            color: var(--text-primary);
        }

        input, select, button {
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            background-color: var(--primary-color);
            color: var(--text-primary);
            font-size: 0.9rem;
            margin: 5px 5px 5px 0;
            transition: all 0.2s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(15, 52, 96, 0.3);
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 400;
            transition: all 0.2s ease;
        }

        button:hover {
            background-color: var(--highlight-color);
        }
        
        /* ============================================================================
   STYLE GLASS POUR LES MENUS DÉROULANTS
============================================================================ */

select {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.1) 0%, 
        rgba(255, 255, 255, 0.05) 100%) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    border-radius: 8px !important;
    color: var(--text-primary) !important;
    padding: 12px 15px !important;
    font-size: 0.95rem !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
}

/* Flèche personnalisée */
select {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12' fill='none'%3E%3Cpath d='M3 5L6 8L9 5' stroke='%23f0f0f0' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E") !important;
    background-repeat: no-repeat !important;
    background-position: right 15px center !important;
    background-size: 12px !important;
    padding-right: 40px !important;
}

/* Effet au survol */
select:hover {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.15) 0%, 
        rgba(255, 255, 255, 0.08) 100%) !important;
    border-color: rgba(255, 255, 255, 0.3) !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2) !important;
}

/* Effet quand ouvert */
select:focus {
    outline: none !important;
    border-color: rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1) !important;
}

/* Options du menu déroulant */
select option {
    background: var(--primary-color) !important;
    color: var(--text-primary) !important;
    border: none !important;
    padding: 12px 15px !important;
}

/* Style pour les selects désactivés */
select:disabled {
    opacity: 0.6 !important;
    cursor: not-allowed !important;
}

        /* ============================================================================
           COMPOSANTS SPÉCIFIQUES
        ============================================================================ */
        .chart-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
            background-color: var(--secondary-color);
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .results {
            margin-top: 20px;
            padding: 20px;
            background-color: var(--secondary-color);
            border-left: 4px solid var(--accent-color);
        }

        .number-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .number-ball {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1em;
            color: white;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .number-ball:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .number-ball-chance {
            background: #1E3A5F !important; /* Couleur unie */
        }

        .prediction-card {
            padding: 15px;
            border: 1px solid var(--border-color);
            width: 31%;
            min-height: 1px;
            display: inline-block;
            margin: 1%;
            vertical-align: top;
            background-color: var(--card-bg);
            border-radius: 8px;
        }

        .stat-card {
    background-color: var(--secondary-color);
    color: var(--text-primary);
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--border-color);
    border-radius: 8px;
}

        .stat-card h4 {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .stat-card .value {
            font-size: 1.2rem;
            font-weight: 300;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .info-box {
        background: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px; /* ← MODIFIEZ ICI */
        padding: 20px;
        margin: 0 0 25px 0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

/* Chart containers */
.chart-container {
    border-radius: 8px; /* Même arrondi */
}

/* Control groups */
.control-group {
    border-radius: 8px; /* Même arrondi */
}

        .success-box {
            background-color: rgba(15, 52, 96, 0.3);
            border: 1px solid var(--accent-color);
            padding: 15px;
            margin: 15px 0;
            color: var(--text-primary);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--secondary-color);
            color: var(--text-primary);
            font-weight: 400;
        }

        tr:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* ============================================================================
           GRILLES DE SÉLECTION
        ============================================================================ */
        .grid-selection {
            margin: 20px 0;
        }

        .grid-title {
            margin-bottom: 15px;
            font-weight: 400;
            color: var(--text-primary);
        }

        .number-grid-select {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            max-width: 40%;
        }

        .number-ball-select {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
            color: white;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .number-ball-select.selected {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid #fff;
        }

       .number-ball-chance-select:hover {
    .number-ball-chance-select:hover {
    transform: scale(1.05); 
    opacity: 0.9; 
}
        }

        .chance-grid-select {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            max-width: 40px;
        }
/* ============================================================================
   CORRECTION DES BOULES CHANCE CARRÉES
============================================================================ */

.number-ball-chance-select {
    border-radius: 50% !important; /* Les rend rondes */
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.9em;
    color: white;
    background-color: var(--highlight-color);
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid transparent;
}

.number-ball-chance-select.selected {
   background: #1E3A5F !important; /* Même couleur que normale */
    transform: scale(1.1);
    border: 2px solid #fff;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); /* Léger halo blanc */
}

.number-ball-chance-select:hover {
    transform: scale(1.05);
}

        .selected-numbers {
            margin: 20px 0;
            padding: 15px;
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
            
        }

        .selected-numbers-display {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
/* ============================================================================
   RESPONSIVE DESIGN - MENU HAMBURGER MOBILE
============================================================================ */

/* Bouton hamburger (caché sur desktop) */
.mobile-menu-toggle {
    display: none;
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 1000;
    background: linear-gradient(135deg, var(--accent-color) 0%, var(--highlight-color) 100%);
    color: white;
    border: none;
    padding: 12px 15px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.5rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    font-weight: bold;
    line-height: 1;
    animation: pulseMenu 2s infinite;
}

.mobile-menu-toggle:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(233, 69, 96, 0.5);
}

.mobile-menu-toggle:active {
    transform: scale(0.95);
}

/* Animation du bouton */
@keyframes pulseMenu {
    0%, 100% {
        box-shadow: 0 4px 15px rgba(233, 69, 96, 0.3);
    }
    50% {
        box-shadow: 0 4px 25px rgba(233, 69, 96, 0.6);
    }
}

.mobile-menu-toggle:hover {
    background-color: var(--highlight-color);
}

/* Overlay pour fermer le menu */
.menu-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 98;
}

.menu-overlay.active {
    display: block;
}

/* Tablettes (768px - 1024px) */
@media (max-width: 1024px) {
    .sidebar {
        width: 200px;
    }
    
    .main-content {
        margin-left: 200px;
    }
    
    .number-grid-select {
        grid-template-columns: repeat(7, 1fr);
        gap: 10px;
        max-width: 100%;
    }
    
    .header h2 {
        font-size: 1.2rem;
    }
}

/* Tablettes et smartphones (< 768px) */
@media (max-width: 768px) {
    :root {
        --header-height: 60px;
    }
    
    /* Afficher le bouton hamburger */
    .mobile-menu-toggle {
        display: block;
    }
    
    /* Sidebar devient un menu coulissant */
    .sidebar {
        position: fixed;
        left: -100%;
        top: 0;
        width: 280px;
        height: 100vh;
        z-index: 99;
        transition: left 0.3s ease;
        overflow-y: auto;
    }
    
    .sidebar.active {
        left: 0;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
    }
    
    .main-content {
        margin-left: 0;
        width: 100%;
    }
    
    .logo {
        padding: 20px;
        border-bottom: 1px solid var(--border-color);
    }
    
    .logo h1 {
        font-size: 1.3rem;
    }
    
    .nav-menu {
        display: block;
        padding: 10px 0;
    }
    
    .nav-item {
        display: flex;
        padding: 15px 20px;
        border-left: 3px solid transparent;
        border-bottom: none;
        font-size: 0.9rem;
    }
    
    .nav-item.active {
        border-left-color: var(--highlight-color);
        border-bottom: none;
    }
    
    .header {
        height: 60px;
        padding: 0 15px 0 70px !important;
    }
    
    .header h2 {
        font-size: 0.95rem;
    }
    
    .content {
        padding: 15px;
    }
    
    .section {
        padding: 15px;
    }
    
    .section h2 {
        font-size: 1.3rem;
    }
    
    .number-grid-select {
        grid-template-columns: repeat(7, 1fr);
        gap: 8px;
        max-width: 100%;
    }
    
    .number-ball-select,
    .number-ball-chance-select {
        width: 35px;
        height: 35px;
        font-size: 0.85em;
    }
    
    .prediction-card {
        width: 100%;
        margin: 10px 0;
    }
    
    .grid-2 {
        grid-template-columns: 1fr;
    }
    
    .chart-container {
        height: 300px;
    }
    
    button, input, select {
        font-size: 0.9rem;
        padding: 10px;
    }
}

/* Smartphones moyens (414px - 600px) */
        
@media (max-width: 600px) {
    .mobile-menu-toggle {
        top: 10px;
        left: 10px;
        padding: 8px 12px;
        font-size: 1.1rem;
    }
    
    .sidebar {
        width: 260px;
    }
    
    .header {
        padding: 0 10px 0 65px !important;
    }
    
    .header h2 {
        font-size: 0.85rem;
    }
    
    .logo h1 {
        font-size: 1.2rem;
    }
    
    .nav-item {
        padding: 12px 15px;
        font-size: 0.85rem;
    }
    
    .number-grid-select {
        grid-template-columns: repeat(7, 1fr);
        gap: 6px;
    }
    
    .chance-grid-select {
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
    }
    
    .number-ball-select,
    .number-ball-chance-select {
        width: 32px;
        height: 32px;
        font-size: 0.8em;
    }
    
    .number-ball {
        width: 35px;
        height: 35px;
        font-size: 0.9em;
    }
    
    .control-group {
        padding: 15px;
    }
    
    .control-group label {
        font-size: 0.9rem;
    }
    
    .period-options {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
    }
    
    .period-btn {
        flex: 1 1 calc(50% - 5px);
        font-size: 0.8rem;
        padding: 8px 5px;
    }
    
    .stat-card h4 {
        font-size: 0.85rem;
    }
    
    .stat-card .value {
        font-size: 1.1rem;
    }
}

/* Petits smartphones (360px - 414px) */
        
@media (max-width: 414px) {
    .mobile-menu-toggle {
        top: 8px;
        left: 8px;
        padding: 7px 10px;
        font-size: 1rem;
    }
    
    .sidebar {
        width: 240px;
    }
    
    .header {
        height: 55px;
        padding: 0 8px 0 60px !important;
    }
    
    .header h2 {
        font-size: 0.75rem;
    }
    
    .section h2 {
        font-size: 1.1rem;
    }
    
    .number-grid-select {
        grid-template-columns: repeat(7, 1fr);
        gap: 5px;
    }
    
    .number-ball-select,
    .number-ball-chance-select {
        width: 28px;
        height: 28px;
        font-size: 0.75em;
    }
    
    .number-ball {
        width: 32px;
        height: 32px;
        font-size: 0.85em;
    }
    
    .chart-container {
        height: 250px;
        padding: 10px;
    }
    
    button, input, select {
        font-size: 0.85rem;
        padding: 8px;
    }
    
    .info-box, .success-box {
        padding: 12px;
        font-size: 0.9rem;
    }
    
    .grid-title {
        font-size: 0.9rem;
    }
}

/* Très petits smartphones (320px - 360px) - 5.5 pouces */
        
@media (max-width: 360px) {
    .mobile-menu-toggle {
        top: 5px;
        left: 5px;
        padding: 6px 8px;
        font-size: 0.9rem;
    }
    
    .sidebar {
        width: 220px;
    }
    
    .logo {
        padding: 15px 10px;
    }
    
    .logo h1 {
        font-size: 1rem;
    }
    
    .logo p {
        font-size: 0.7rem;
    }
    
    .nav-item {
        padding: 10px 12px;
        font-size: 0.8rem;
    }
    
    .header {
        height: 50px;
        padding: 0 5px 0 55px !important;
    }
    
    .header h2 {
        font-size: 0.7rem;
    }
    
    .content {
        padding: 10px;
    }
    
    .section {
        padding: 10px;
    }
    
    .section h2 {
        font-size: 1rem;
        margin-bottom: 15px;
    }
    
    .section h3 {
        font-size: 1rem;
    }
    
    .number-grid-select {
        grid-template-columns: repeat(7, 1fr);
        gap: 4px;
    }
    
    .chance-grid-select {
        grid-template-columns: repeat(5, 1fr);
        gap: 6px;
    }
    
    .number-ball-select,
    .number-ball-chance-select {
        width: 26px;
        height: 26px;
        font-size: 0.7em;
    }
    
    .number-ball {
        width: 30px;
        height: 30px;
        font-size: 0.8em;
    }
    
    .control-group {
        padding: 10px;
    }
    
    .control-group label {
        font-size: 0.85rem;
        margin-bottom: 6px;
    }
    
    button, input, select {
        font-size: 0.8rem;
        padding: 7px;
        margin: 3px 3px 3px 0;
    }
    
    .period-btn {
        font-size: 0.7rem;
        padding: 6px 4px;
    }
    
    .chart-container {
        height: 200px;
        padding: 8px;
    }
    
    .stat-card {
        padding: 10px;
    }
    
    .stat-card h4 {
        font-size: 0.8rem;
    }
    
    .stat-card .value {
        font-size: 1rem;
    }
    
    .info-box, .success-box {
        padding: 10px;
        font-size: 0.85rem;
    }
    
    .info-box ul, .success-box ul {
        margin-left: 15px;
        font-size: 0.8rem;
    }
    
    .grid-title {
        font-size: 0.85rem;
        margin-bottom: 10px;
    }
    
    .selected-numbers-display {
        gap: 6px;
    }
    
    .prediction-card {
        padding: 10px;
        margin: 8px 0;
    }
    
    table {
        font-size: 0.8rem;
    }
    
    th, td {
        padding: 8px 4px;
    }
}

/* Orientation paysage sur mobile */
        
@media (max-height: 500px) and (orientation: landscape) {
    .header {
        height: 45px;
    }
    
    .header h2 {
        font-size: 0.8rem;
    }
    
    .chart-container {
        height: 250px;
    }
    
    .section {
        padding: 10px;
    }
    
    .number-grid-select {
        grid-template-columns: repeat(10, 1fr);
    }
}
        .selected-numbers-display .number-ball,
    .selected-numbers-display .number-ball-chance {
        transform: none !important;
    }

    .selected-numbers-display .number-ball:hover,
    .selected-numbers-display .number-ball-chance:hover {
        transform: none !important;
    }
        /* Effet au survol pour la sélection */
        
.number-ball-select:hover {
    transform: scale(1.1);
    transition: transform 0.2s ease;
}

/* Effet quand sélectionnées */
.number-ball-select.selected {
    transform: scale(1.15);
    border: 2px solid #fff;
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
    transition: all 0.2s ease;
}
        
/* ============================================================================
       RÉGLAGE DES ESPACES - PAGE D'ACCUEIL
    ============================================================================ */
    
    /* Introduction */
    #overview .section p {
        margin-bottom: 30px;
    }
    
    /* Dernier tirage */
    .latest-draw {
        margin: 0 0 20px 0;
        padding: 0px;
    }
    
    .latest-draw-numbers {
        display: flex;
        gap: 12px;
        justify-content: center;
    }
    
    /* Sélection période */
    .control-group {
        margin: 0 0 8px 0;
        padding: 20px;
    }
    
    .period-options {
        display: flex;
        gap: 10px;
    }
    
    /* Cartes stats */
    .grid-2 {
        gap: 20px;
        margin: 0 0 25px 0;
    }
    
    /* Liste fonctionnalités */
    .info-box {
        margin: 0 0 8px 0;
        padding: 20px;
    }
    
    /* Bouton final */
    #overview .section button {
        margin: 1px 0 0 0;
        width: ;
    }

              /* ============================================================================
       RÉGLAGE DES ESPACES - ONGLET MACHINE LEARNING
    ============================================================================ */
    
    /* Titre principal */
    #ml .section h2 {
        margin-bottom: 20px;
    }
    
    /* Paragraphe d'introduction */
    #ml .section p {
        margin-bottom: 25px;
    }
    
    /* Boîte d'information ML */
    #ml .info-box {
        margin: 0 0 20px 0;
        padding: 20px;
    }
    
    /* Contenu d'explication ML */
    #mlExplanationContent {
        margin-bottom: 20px;
    }
    
    /* Groupe de contrôle ML */
    #ml .control-group {
        margin: 1 1 5px 1;
        padding: 20px;
    }
    
    /* Sélecteur d'algorithme */
    #mlModel {
        margin: 0 1px px 0; /* Espace à droite et en bas */
    }
    
    /* Section des features */
    #ml .control-group div {
        margin: 15px 0;
        padding: 15px;
    }
    
    /* Bouton d'entraînement */
    #ml .control-group button {
        margin: px 0 0 0;
    }
    
    /* Indicateur de chargement */
    #mlLoading {
        margin: 0px 0;
    }
    
    /* Métriques ML */
    #mlMetrics {
        gap: 20px;
        margin: 0 0 0px 0;
    }
    
    /* Résultats ML */
    #mlResults {
        margin: 20px 0;
    }
    
    /* Graphique ML */
    #ml .chart-container {
        margin: 0 0 0px 0;
    }
    
              /* ============================================================================
       RÉGLAGE DES ESPACES - ONGLET FRÉQUENCES
    ============================================================================ */
    #frequencies .section h2 {
        margin-bottom: 20px;
    }
    
    #frequencies .section p {
        margin-bottom: 20px;
    }
    
    #frequencies .control-group {
        margin: 0 0 20px 0;
        padding: 20px;
    }
    
    #frequencies .section select,
    #frequencies .section button {
        margin: 0 10px 10px 0;
    }
    
    #frequencies .chart-container {
        margin: 0 0 20px 0;
    }
    
    #freqResults {
        margin: 20px 0;
    }
    
    #frequencies .info-box {
        margin: 0 0 20px 0;
        padding: 20px;
    }


    /* ============================================================================
       RÉGLAGE DES ESPACES - ONGLET Probabilités
    ============================================================================ */
   #predictions .section h2 {
        margin-bottom: 15px;
    }
    
    #predictions .section p {
        margin-bottom: 20px;
    }
    
    #predictions .control-group {
        margin: 0 0 20px 0;
        padding: 20px;
    }
    
    #predictions .section select,
    #predictions .section input,
    #predictions .section button {
        margin: 0 0px 10px 0;
    }
    
    #predictionExplanations {
        margin: 20px 0;
    }
    
    #predLoading {
        margin: 20px 0;
    }
    
    #predResults {
        margin: 20px 0;
    }
    
    #predictions .info-box {
        margin: 0 0 25px 0;
        padding: 20px;
    }

    /* ============================================================================
       RÉGLAGE DES ESPACES - ONGLET CLUSTERING
    ============================================================================ */
    #clusters .section h2 {
        margin-bottom: 20px;
    }
    
    #clusters .section p {
        margin-bottom: 20px;
    }
    
    #clusters .control-group {
        margin: 0 0 20px 0;
        padding: 20px;
    }
    
    #clusters .section input,
    #clusters .section button {
        margin: 1 10px 1px 0;
    }
    
    #clusters .chart-container {
        margin: 0 0 20px 0;
    }
    
    #clusterResults {
        margin: 20px 0;
    }
    
    #clusters .info-box {
        margin: 0 0 25px 0;
        padding: 20px;
    }
        
    /* ============================================================================
       RÉGLAGE DES ESPACES - ONGLET STATISTIQUES
    ============================================================================ */
    #statistics .section h2 {
        margin-bottom: 20px;
    }
    
    #statistics .section p {
        margin-bottom: 1px;
    }
    
    #statistics .control-group {
        margin: 0 0 25px 0;
        padding: 20px;
    }
    
    #statistics .section select,
    #statistics .section button {
        margin: 0 10px 10px 0;
    }
    
    #statistics .chart-container {
        margin: 0 0 1px 0;
    }
    
    #statResults {
        margin: 20px 0;
    }

    /* ============================================================================
       RÉGLAGE DES ESPACES - ONGLET ÉVALUATION
    ============================================================================ */
    #evaluation .section h2 {
        margin-bottom: 20px;
    }
    
    #evaluation .section p {
        margin-bottom: 20px;
    }
    
    #evaluation .control-group {
        margin: 0 0 25px 0;
        padding: 20px;
    }
    
    #evaluation .grid-selection {
        margin: 20px 0;
    }
    
    #evaluation .number-grid-select,
    #evaluation .chance-grid-select {
        margin: 0 0 20px 0;
    }
    
    #evaluation .selected-numbers {
        margin: 20px 0;
    }
    
    #evaluation .section button {
        margin: 0 10px 10px 0;
    }
    
    #evaluation .chart-container {
        margin: 0 0 25px 0;
    }
    
    #evalResults {
        margin: 20px 0;
    }

    /* ============================================================================
       RÉGLAGE DES ESPACES - ONGLET SIMULATION
    ============================================================================ */
    #simulation .section h2 {
        margin-bottom: 20px;
    }
    
    #simulation .section p {
        margin-bottom: 20px;
    }
    
    #simulation .control-group {
        margin: 0 0 25px 0;
        padding: 20px;
    }
    
    #simulation .grid-selection {
        margin: 1px 0;
    }
    
    #simulation .number-grid-select,
    #simulation .chance-grid-select {
        margin: 0 0 20px 0;
    }
    
    #simulation .selected-numbers {
        margin: 20px 0;
    }
    
    #simulation .section input,
    #simulation .section button {
        margin: 0 10px 10px 0;
    }
    
    #simLoading {
        margin: 20px 0;
    }
    
    #simulation .chart-container {
        margin: 0 0 25px 0;
    }
    
    #simMetrics {
        gap: 20px;
        margin: 0 0 25px 0;
    }
    
    #simResults {
        margin: 20px 0;
    }
    
    #simulation .info-box {
        margin: 0 0 25px 0;
        padding: 20px;
    }

    /* ============================================================================
       RÉGLAGE DES ESPACES - ONGLET PROGRAMME
    ============================================================================ */
    #programme .section h2 {
        margin-bottom: px;
    }
    
    #programme .section p {
        margin-bottom: 25px;
    }
    
    #programme .section h3 {
        margin: 25px 0 15px 0;
    }
    
    #programme .control-group {
        margin: 0 0 25px 0;
        padding: 20px;
    }
    
    #programme .section select {
        margin: 0 10px 15px 0;
    }
    
    #programme .code-actions {
        gap: 10px;
        margin: 15px 0;
    }
    
    #programme .code-container {
        margin: 20px 0;
    }
    
    #programme .info-box {
        margin: 0 0 25px 0;
        padding: 20px;
    }

.latest-draw.glass-card h4 {
    color: var(--text-primary) !important;
    margin-bottom: 15px !important;
    font-size: 1.2rem !important;
}

/* Style glass pour le conteneur des boules */

        .latest-draw-numbers {
    background: rgba(255, 255, 255, 0.0) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    border-radius: 8px !important;
    padding: 15px !important;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05) !important; /* ← CHANGÉ */
}
        
        /* Correction des artefacts visuels du glass sur fond dégradé */
        
.glass-card {
    background: rgba(255, 255, 255, 0.06); /* couleur unie au lieu d'un gradient */
    backdrop-filter: blur(10px) saturate(120%);
    -webkit-backdrop-filter: blur(10px) saturate(120%);
}
        

    </style>
</head>
<body>
    
    <!-- Bouton menu hamburger -->
    <button class="mobile-menu-toggle" id="mobileMenuToggle">☰</button>

    <!-- Overlay pour fermer le menu -->
    <div class="menu-overlay" id="menuOverlay"></div>
    
    <!-- Barre latérale -->
    <div class="sidebar">
        <div class="logo">
            <h1>LTsTaT</h1>
            <p>Analyseur Probabiliste</p>
        </div>
        
        <div class="nav-menu">
            <div class="nav-item active" onclick="showTab('overview')">
                <i></i> Accueil
            </div>
            <div class="nav-item" onclick="showTab('frequencies')">
                <i></i> Fréquences
            </div>
            <div class="nav-item" onclick="showTab('predictions')">
                <i></i> Probabilités
            </div>
            <div class="nav-item" onclick="showTab('ml')">
                <i></i> Machine Learning
            </div>
            <div class="nav-item" onclick="showTab('clusters')">
                <i></i> Clustering
            </div>
            <div class="nav-item" onclick="showTab('statistics')">
                <i></i> Statistiques
            </div>
            <div class="nav-item" onclick="showTab('evaluation')">
                <i></i> Évaluation
            </div>
            <div class="nav-item" onclick="showTab('simulation')">
                <i></i> Simulation
            </div>
            <div class="nav-item" onclick="showTab('programme')">
                <i></i> Programme
            </div>
        </div>
    </div>
    
    <!-- Contenu principal -->
    <div class="main-content">
        <div class="header">
            <h2 id="appStatus">Analyse Statistique et Prédictive du Loto</h2>
        </div>
        
        <div class="content">
            <!-- Onglet Accueil -->
            <div id="overview" class="tab-content active">
                <div class="section">
                    <h2>Accueil</h2>
                    <p style="font-size: 1.1em; line-height: 1.6; margin: 20px 0;">
                        L'application analyse l'historique complet des tirages du Loto 
                        en utilisant des méthodes statistiques avancées, de machine learning et des simulations probabilistes.
                    </p>
                         
                    <div id="latestDrawContainer" style="display: none;">
                        <div class="latest-draw glass-card">
                            <h4>Dernier Tirage</h4>
                            <div id="latestDrawDate" style="font-weight: bold; margin-bottom: 10px;"></div>
                            <div class="latest-draw-numbers" id="latestDrawNumbers"></div>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3 style="color: var(--text-primary); margin-bottom: 15px;">Sélection de la Période d'Analyse</h3>
                        <div class="period-selector">
                            <label>Période :</label>
                            <div class="period-options">
                                <button class="period-btn active" onclick="setPeriod('all')">Tous les tirages</button>
                                <button class="period-btn" onclick="setPeriod('year')">Année</button>
                                <button class="period-btn" onclick="setPeriod('month')">Mois</button>
                                <button class="period-btn" onclick="setPeriod('custom')">Période personnalisée</button>
                            </div>
                        </div>
                        
                        <div id="yearSelector" class="period-selector" style="display: none; margin-top: 10px;">
                            <label>Année :</label>
                            <select id="yearSelect" onchange="applyPeriodFilter()">
                                <option value="">Sélectionnez une année</option>
                            </select>
                        </div>
                        
                        <div id="monthSelector" class="period-selector" style="display: none; margin-top: 10px;">
                            <label>Mois :</label>
                            <select id="monthSelect" onchange="applyPeriodFilter()">
                                <option value="">Sélectionnez un mois</option>
                                <option value="01">Janvier</option>
                                <option value="02">Février</option>
                                <option value="03">Mars</option>
                                <option value="04">Avril</option>
                                <option value="05">Mai</option>
                                <option value="06">Juin</option>
                                <option value="07">Juillet</option>
                                <option value="08">Août</option>
                                <option value="09">Septembre</option>
                                <option value="10">Octobre</option>
                                <option value="11">Novembre</option>
                                <option value="12">Décembre</option>
                            </select>
                            <select id="monthYearSelect" onchange="applyPeriodFilter()">
                                <option value="">Sélectionnez une année</option>
                            </select>
                        </div>
                        
                        <div id="customPeriodSelector" class="period-selector" style="display: none; margin-top: 10px;">
                            <label>Période personnalisée :</label>
                            <div class="date-inputs">
                                <input type="date" id="startDate" onchange="applyPeriodFilter()">
                                <span>au</span>
                                <input type="date" id="endDate" onchange="applyPeriodFilter()">
                            </div>
                        </div>
                    </div>

                    <div class="grid-2">
                        <div class="stat-card">
                            <h4>Tirages Analysés</h4>
                            <div class="value" id="statTotalDraws">0</div>
                            <small id="periodInfo">Période: Tous les tirages</small>
                        </div>
                        <div class="stat-card">
                            <h4>Période Couverte</h4>
                            <div class="value" id="statPeriod">Réelle</div>
                            <small id="dateRange">-</small>
                        </div>
                        <div class="stat-card">
                            <h4>Premier Tirage</h4>
                            <div class="value" id="firstDrawDate">-</div>
                        </div>
                        <div class="stat-card">
                            <h4>Dernier Tirage</h4>
                            <div class="value" id="lastDrawDate">-</div>
                        </div>
                    </div>

                    <div class="info-box" style="margin-top: 30px;">
                        <h3 style="color: var(--text-primary); margin-bottom: 10px;">Fonctionnalités du programme</h3>
                        <ul style="line-height: 2; margin-left: 20px;">
                            <li><strong>Analyse des Fréquences :</strong> Visualisez les numéros les plus et moins fréquents</li>
                            <li><strong>Prévisons Statistiques :</strong> Algorithmes basés sur les distributions de Poisson, Loi de Zipf, Test T Student, Test Chi-carré, Distribution Binomiale, Distribution de Dirichlet</li>
                            <li><strong>Machine Learning Réel :</strong> Modèles de classification avancés (Random Forest, Gradient Boosting, Régression Logistique, LSTM Deep Learning, Ensemble Stacking)</li>
                            <li><strong>Clustering K-Means :</strong> Identification de groupes de numéros similaires</li>
                            <li><strong>Simulations Monte Carlo :</strong> Testez vos stratégies avec des milliers de tirages simulés</li>
                            <li><strong>Analyses Statistiques :</strong> Tests de significativité, corrélations, et tendances temporelles</li>
                        </ul>
                    </div>

                    <button onclick="showTab('frequencies')" style="margin-top: 20px; width: 100%; padding: 15px; font-size: 1.1em;">
                        Commencer l'Analyse →
                    </button>
                </div>
            </div>

            <!-- Onglet Fréquences -->
            <div id="frequencies" class="tab-content">
                <div class="section">
                    <h2>Analyse des Fréquences</h2>
                    <p>Visualisez la fréquence d'apparition de chaque numéro dans l'historique des tirages.</p>
                    
                    <div class="control-group">
                        <label>Type d'analyse :</label>
                        <select id="freqType" onchange="updateFrequencyChart()">
                            <option value="main">Numéros Principaux (1-49)</option>
                            <option value="chance">Numéros Chance (1-10)</option>
                        </select>
                        <button onclick="updateFrequencyChart()">Générer le Graphique</button>
                    </div>
                    
                    <div class="info-box">
                        <h4>Analyse des Fréquences</h4>
                        <p>Cette technique est essentielle pour identifier les tendances historiques des numéros.</p>
                    </div>

                    <div class="chart-container">
                        <canvas id="frequencyChart"></canvas>
                    </div>

                    <div id="freqResults" class="info-box glass-card"></div>

                    <div class="info-box">
                        <strong>Information :</strong> Les numéros les plus fréquents ne sont pas nécessairement 
                        les plus "chanceux" - chaque tirage est indépendant. Cette analyse montre simplement les tendances historiques.
                    </div>
                </div>
            </div>

            <!-- Onglet Probabilités -->
            
            <div id="predictions" class="tab-content">
                <div class="section">
                    <h2>Probabilités Statistiques</h2>
                    <p>Générez des combinaisons basées sur différents modèles probabilistes.</p>
                    
                    <div class="info-box">
                        <h4> Modèle de Probabilités</h4></p>
                        <p>Les simulations sont des algorithmes utilisés dans le but d'estimer la probabilité d'occurrence d'un scénario dans lequel interviennent des paramètres aléatoires. C'est une technique statistique permettant de comprendre l'influence de l'incertitude dans les modèles de Probabilités.</p>
                        <strong>Distributions Statistiques Utilisées :</strong></p>
                        <p><strong>Poisson :</strong> Modélise la probabilité qu'un certain nombre d'événements (apparitions d'un numéro) se produisent dans un intervalle de temps donné. Utile pour les faibles fréquences (numéros "en retard").</p>
                        <p><strong>Binomiale :</strong> Modélise le nombre de succès (apparitions d'un numéro) dans une séquence de n tirages indépendants, chacun ayant une probabilité p de succès.</p>
                        <p><strong>Dirichlet :</strong> Distribution complexe souvent utilisée pour modéliser des proportions de catégories. Dans le contexte du Loto, elle peut modéliser la probabilité que les cinq numéros choisis se répartissent de manière déséquilibrée sur les quatre dizaines.</p>
                        <p><strong>Tests Statistiques :</strong></p>
                        <p><strong>Test T (Student) :</strong> Permet de comparer la moyenne d'une série de numéros avec une valeur théorique pour déterminer si l'écart est significatif.</p>
                        <p><strong>Test du Chi-carré (χ²) :</strong> Le test essentiel pour le Loto. Il permet de vérifier si la distribution observée des fréquences des numéros est conforme à une distribution uniforme théorique.</p>
                        <p><strong>Analyse en Composantes Principales (PCA) :</strong> Outil de </p>
                    </div>

                    <div class="control-group">
                        <label>Modèle de Probabilités :</label>
                        <select id="predModel" onchange="togglePredictionOptions()">
                            <option value="montecarlo">Simulation Monte-Carlo</option>
                            <option value="poisson">Distribution de Poisson</option>
                            <option value="dirichlet">Distribution de Dirichlet</option>
                            <option value="binomiale">Distribution Binomiale</option>
                            <option value="gamma">Distribution Gamma</option>
                            <option value="chisquare">Test du Chi-carré (χ²)</option>
                            <option value="student">Test T de Student</option>
                            <option value="zipf">Loi de Zipf</option>
                            <option value="hybrid">Modèle Hybride</option>
                        </select>
                        <br>
                    
                        
                        
                        <div id="standardOptions">
                            <label>Nombre de combinaisons :</label>
                            <input type="number" id="numPredictions" value="6" min="1" max="20">
                        </div>
                        
                        <div id="testOptions" style="display: none;">
                            <label>Seuil de significativité (α) :</label>
                            <input type="number" id="alphaLevel" value="0.05" min="0.01" max="0.1" step="0.01">
                        </div>
                        
                        <div id="monteCarloOptions" style="display: none;">
                            <label>Nombre de simulations Monte-Carlo :</label>
                            <input type="number" id="numMonteCarloSims" value="10000" min="1000" max="100000" step="1000">
                            <br>
                            <label>Top combinaisons à afficher :</label>
                            <input type="number" id="topMonteCarlo" value="10" min="5" max="20">
                        </div>
                        
                        <button onclick="generatePredictions()">Générer des Probabilités</button>
                    </div>
                
                <div id="predictionExplanations" class="info-box glass-card" style="margin: 20px 0;">
            </div>
                    <div class="loading" id="predLoading">
                        <div class="progress-container">
                            <div class="progress-bar" id="predProgressBar"></div>
                        </div>
                        <div class="progress-text" id="predProgressText">Initialisation de l'analyse probabiliste...</div>
                        <div class="progress-stats">
                            <span id="predProgressStep">Étape 1/4</span>
                            <span class="progress-percentage" id="predProgressPercent">0%</span>
                            <span id="predProgressTime">Temps estimé: --</span>
                        </div>
                    </div>

                    <div id="predResults"></div>

                    <div class="info-box" style="margin-top: 20px;">
                       Ces Probabilités sont purement statistiques. 
                        La loterie est un jeu de hasard où chaque tirage est indépendant. Aucun algorithme ne peut garantir un gain.
                    </div>
                </div>
            </div>

            <!-- Onglet Machine Learning -->
            <div id="ml" class="tab-content">
                <div class="section">
                    <h2>Probabilités par Machine Learning</h2>
                    <p>Utilisez des algorithmes d'apprentissage automatique entraînés sur l'historique des tirages.</p>

                    <div class="info-box">
                        <h4>Algorithmes ML Implémentés</h4>
                        <div id="mlExplanationContent">
                            <p><strong>Tous les modèles entraînés sur les données réelles</strong></p>
                            <p>Features utilisées : fréquences historiques, temps depuis dernière apparition, patterns statistiques, tendances temporelles</p>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Algorithme :</label>
                        <select id="mlModel">
                            <option value="rf">Random Forest</option>
                            <option value="gb">Gradient Boosting</option>
                            <option value="logistic">Régression Logistique</option>
                            <option value="ensemble">Ensemble (Stacking)</option>
                            <option value="lstm">LSTM (Deep Learning)</option>
                        </select>
                        <br>
                        <button onclick="trainMLModel()">Entraîner et Prédire</button>
                    </div>

                    <div class="loading" id="mlLoading">
                        <div class="progress-container">
                            <div class="progress-bar" id="mlProgressBar"></div>
                        </div>
                        <div class="progress-text" id="mlProgressText">Préparation du modèle de Machine Learning...</div>
                        <div class="progress-stats">
                            <span id="mlProgressStep">Étape 1/5</span>
                            <span class="progress-percentage" id="mlProgressPercent">0%</span>
                            <span id="mlProgressTime">Temps estimé: --</span>
                        </div>
                    </div>

                    <div class="grid-2" id="mlMetrics"></div>
                    <div id="mlResults"></div>

                    <div class="chart-container">
                        <canvas id="mlChart"></canvas>
                    </div>

                    <div class="info-box" id="mlDetailedExplanation" style="margin-top: 20px; display: none;">
                        <h4>Explications Détaillées du Modèle</h4>
                        <div id="mlDetailedExplanationContent">
                            <p>Sélectionnez un modèle et lancez l'entraînement pour voir les explications détaillées...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Onglet Clustering -->
            
            <div id="clusters" class="tab-content">
                <div class="section">
                    <h2>Analyse par Clustering K-Means</h2>
                    <p>Identifiez des groupes de numéros avec des comportements similaires.</p>

                    <div class="info-box">
                        <h4> Clustering K-means</h4>
                        <p>Cette technique est essentielle pour regrouper les numéros de tirage qui partagent des profils historiques similaires (basés sur la fréquence, l'écart, la tendance). L'utilisateur peut choisir des numéros au sein d'un "cluster gagnant".</p>
                        <p><strong>Analyse en Composantes Principales (PCA) :</strong> Outil de réduction de dimension. Elle permet de transformer un grand nombre de caractéristiques statistiques en un ensemble plus petit de variables non corrélées, tout en conservant la majeure partie de l'information.</p>
                    </div>

                    <div class="control-group">
                        <label>Nombre de clusters :</label>
                        <input type="number" id="numClusters" value="5" min="2" max="10">
                        <button onclick="performClustering()">Créer les Clusters</button>
                    </div>

                    <div class="chart-container">
                        <canvas id="clusterChart"></canvas>
                    </div>

                    <div class="chart-container">
                        <canvas id="clusterDistributionChart"></canvas>
                    </div>

                    <div id="clusterResults"></div>

                    <div class="info-box">
                        <strong>Clustering K-Means :</strong> Cette technique regroupe les numéros ayant des 
                        caractéristiques similaires (fréquence, écarts, tendances). Les numéros d'un même cluster 
                        partagent des patterns communs dans l'historique.
                    </div>
                </div>
            </div>

            <!-- Onglet Statistiques -->
            <div id="statistics" class="tab-content">
                <div class="section">
                    <h2>Analyses Statistiques Avancées</h2>
                    
                    <div class="info-box">
                        <h4>Analyse Statistique</h4>
                        <p>Techniques avancées pour l'analyse des données de tirage.</p>
                    </div>
                    
                    <div class="control-group">
                        <label>Type d'analyse :</label>
                        <select id="statType">
                            <option value="distribution">Distribution des Numéros</option>
                            <option value="parite">Analyse Parité (Pairs/Impairs)</option>
                            <option value="somme">Distribution des Sommes</option>
                            <option value="gaps">Analyse des Écarts</option>
                            <option value="consecutive">Numéros Consécutifs</option>
                        </select>
                        <button onclick="performStatAnalysis()">Lancer l'Analyse</button>
                    </div>

                    <div class="chart-container">
                        <canvas id="statChart"></canvas>
                    </div>

                    <div id="statResults"></div>
                </div>
            </div>

            <!-- Onglet Évaluation -->
            <div id="evaluation" class="tab-content">
                <div class="section">
                    <h2>Évaluer ma Grille de Loto</h2>
                    <p>Analysez votre grille personnelle selon plusieurs critères statistiques et obtenez un score global.</p>
                    
                    <div class="info-box">
                        <h4>Évaluation</h4>
                        <p>Analyse complète de votre grille selon divers critères statistiques.</p>
                    </div>

                    <div class="control-group">
                        <div class="grid-selection">
                            <div class="grid-title">Sélectionnez vos 5 numéros principaux (1-49) :</div>
                            <div class="number-grid-select" id="mainNumbersGrid"></div>
                            
                            <div class="selected-numbers glass-card">
                                <div class="grid-title">Vos numéros sélectionnés :</div>
                                <div class="selected-numbers-display" id="selectedMainNumbers"></div>
                            </div>
                            
                            <div class="grid-title">Sélectionnez votre numéro chance (1-10) :</div>
                            <div class="chance-grid-select" id="chanceNumbersGrid"></div>
                            
                            <div class="selected-numbers glass-card">
                                <div class="grid-title">Votre numéro chance :</div>
                                <div class="selected-numbers-display" id="selectedChanceNumber"></div>
                            </div>
                        </div>
                        
                        <button onclick="evaluateGrid()" style="margin-top: 15px;">Évaluer ma Grille</button>
                        <button onclick="generateRandomGrid()" style="margin-top: 15px; background-color: var(--highlight-color);">Générer une Grille Aléatoire</button>
                    </div>

                    <div class="chart-container">
                        <canvas id="evaluationChart"></canvas>
                    </div>
                    <div id="evalResults" class="info-box glass-card"></div>
                </div>
            </div>

            <!-- Onglet Simulation -->
            
            <div id="simulation" class="tab-content">
                <div class="section">
                    <h2>Simulation Monte Carlo</h2>
                    <p>Simulez des milliers de tirages pour tester des stratégies et estimer des probabilités.</p>
                    
                    <div class="info-box">
                        <h4>Évaluation</h4>
                        <p>Cette technique est essentielle pour...</p>
                    </div>

                    <div class="info-box">
                        <h4>Simulation Monte-Carlo</h4>
                        <p>Les simulations de Monte-Carlo (KMC) sont des algorithmes utilisés dans le but d'estimer la probabilité d'occurrence d'un scénario dans lequel interviennent des paramètres aléatoires. C'est une technique statistique permettant de comprendre l'influence de l'incertitude dans les modèles de Probabilités.</p>
                        <p><strong>Distributions Statistiques Utilisées :</strong></p>
                        <p><strong>Poisson :</strong> Modélise la probabilité qu'un certain nombre d'événements (apparitions d'un numéro) se produisent dans un intervalle de temps donné. Utile pour les faibles fréquences (numéros "en retard").</p>
                        <p><strong>Binomiale :</strong> Modélise le nombre de succès (apparitions d'un numéro) dans une séquence de n tirages indépendants, chacun ayant une probabilité p de succès.</p>
                        <p><strong>Dirichlet :</strong> Distribution complexe souvent utilisée pour modéliser des proportions de catégories. Dans le contexte du Loto, elle peut modéliser la probabilité que les cinq numéros choisis se répartissent de manière déséquilibrée sur les quatre dizaines.</p>
                        <p><strong>Tests Statistiques :</strong></p>
                        <p><strong>Test T (Student) :</strong> Permet de comparer la moyenne d'une série de numéros avec une valeur théorique pour déterminer si l'écart est significatif.</p>
                        <p><strong>Test du Chi-carré (χ²) :</strong> Le test essentiel pour le Loto. Il permet de vérifier si la distribution observée des fréquences des numéros est conforme à une distribution uniforme théorique.</p>
                    </div>

                    <div class="control-group">
                        <div class="grid-selection">
                            <div class="grid-title">Sélectionnez vos 5 numéros principaux (1-49) :</div>
                            <div class="number-grid-select" id="simMainNumbersGrid"></div>
                            
                            <div class="selected-numbers glass-card">

                                <div class="grid-title">Vos numéros sélectionnés :</div>
                                <div class="selected-numbers-display" id="simSelectedMainNumbers"></div>
                            </div>
                            
                            <div class="grid-title">Sélectionnez votre numéro chance (1-10) :</div>
                            <div class="chance-grid-select" id="simChanceNumbersGrid"></div>
                            
                            <div class="selected-numbers glass-card">
                                <div class="grid-title">Votre numéro chance :</div>
                                <div class="selected-numbers-display" id="simSelectedChanceNumber"></div>
                            </div>
                        </div>
                        
                        <label>Nombre de simulations :</label>
                        <input type="number" id="numSims" value="10000" min="100" max="100000">
                        <button onclick="runSimulation()">Lancer la Simulation</button>
                    </div>

                    <div class="loading" id="simLoading">
                        <div class="spinner"></div>
                        <p>Simulation en cours...</p>
                    </div>

                    <div class="grid-2" id="simMetrics"></div>

                    <div class="chart-container">
                        <canvas id="simChart"></canvas>
                    </div>

                    <div class="chart-container">
                        <canvas id="simDistributionChart"></canvas>
                    </div>

                    <div id="simResults"></div>
                </div>
            </div>


            <!-- Onglet Programme -->
            <div id="programme" class="tab-content">
                <div class="section">
                    <h2>Programme</h2>
                    <p>Documentation technique, structure du programme et code source complet.</p>
                    
                    <div class="control-group">
                        <h3>Documentation Technique</h3>
                        <div class="info-box">
                            <p>Cette application utilise des méthodes statistiques avancées et du machine learning pour analyser les tirages du Loto.</p>
                            <p><strong>Version :</strong> Github-3.3</p>
                            <p><strong>Dernière mise à jour :</strong> <span id="currentDate"></span></p>
                        </div>
                        
                        <div style="margin: 20px 0; border-bottom: 1px solid var(--border-color);"></div>
                        
                        <h3>Code Source</h3>
                        <div class="control-group">
                            <label>Sélectionnez le code source à afficher :</label>
                            <select id="codeSourceSelect" onchange="afficherCodeSource()">
                                <option value="">-- Choisir un code source --</option>
                                <option value="html">Code HTML/JavaScript</option>
                                <option value="python">Code Python</option>
                                <option value="css">Code CSS</option>
                                <option value="javascript">Code JavaScript</option>
                            </select>
                            
                            <div class="code-actions" style="display: none; margin-top: 15px;" id="codeActions">
                                <button onclick="copierCode()" class="copy-btn">📋 Copier le code</button>
                                <button onclick="telechargerCode()" class="copy-btn">⬇️ Télécharger</button>
                                <button onclick="afficherCanevas()" class="copy-btn">🎨 Afficher le canevas</button>
                            </div>
                        </div>
                        
                        <div class="info-box">
                            <div id="codeSourceContent">
                                <p>Sélectionnez un code source dans le menu déroulant pour l'afficher ici.</p>
                            </div>
                        </div>
                        
                        <div id="canevasContainer" style="display: none; margin-top: 20px;">
                            <h4>Canevas Synchronisé</h4>
                            <div class="info-box">
                                <div style="display: flex; gap: 20px; min-height: 400px;">
                                    <div style="flex: 1; border-right: 1px solid var(--border-color); padding-right: 20px;">
                                        <h5>Code Source</h5>
                                        <pre id="canevasCode" style="background-color: var(--secondary-color); padding: 15px; overflow-x: auto; font-family: 'Courier New', monospace; font-size: 0.9em; max-height: 350px; overflow-y: auto;"></pre>
                                    </div>
                                    
                                    <div style="flex: 1;">
                                        <h5>Aperçu Visuel</h5>
                                        <div id="canevasPreview" style="background: white; padding: 15px; border-radius: 8px; min-height: 350px; border: 1px solid var(--border-color);">
                                            <p style="color: black; text-align: center; margin-top: 150px;">Aperçu du code sélectionné</p>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="margin-top: 15px; display: flex; gap: 10px;">
                                    <button onclick="masquerCanevas()" class="copy-btn">✕ Masquer le canevas</button>
                                    <button onclick="actualiserApercu()" class="copy-btn">🔄 Actualiser l'aperçu</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // VARIABLES GLOBALES ET CONFIGURATION
        // ============================================================================

        let charts = {};
        let historicalData = null; 
        let realDrawData = []; 
        let isRealDataLoaded = false;
        
        // Variables pour les modèles ML
        let mlModels = {
            rf: null,
            gb: null,
            logistic: null,
            ensemble: null,
            lstm: null
        };

        // Variables pour les grilles de sélection
        let selectedMainNumbers = [];
        let selectedChanceNumber = null;
        let simSelectedMainNumbers = [];
        let simSelectedChanceNumber = null;

        // Variables pour la gestion des périodes
        let currentPeriod = 'all';
        let filteredDraws = [];
        let availableYears = [];

        // ============================================================================
        // DONNÉES RÉELLES INTÉGRÉES
        // ============================================================================

        const realLotoDataCSV = `date;boule_1;boule_2;boule_3;boule_4;boule_5;numero_chance
13/10/25;2;11;36;45;49;7
11/10/25;5;3;40;32;12;4
08/10/25;5;47;39;10;25;7
06/10/25;22;10;30;1;26;9
04/10/25;6;45;31;29;4;8
01/10/25;10;5;41;35;44;7
29/09/25;27;32;44;5;17;4
27/09/25;45;46;3;19;11;4
24/09/25;3;32;21;23;31;4
22/09/25;10;41;5;29;47;4
20/09/25;36;18;10;39;47;7
17/09/25;2;25;47;32;37;3
15/09/25;30;2;10;32;17;5
13/09/25;29;31;6;41;28;10
10/09/25;18;49;14;24;17;7
08/09/25;30;42;21;10;22;8
06/09/25;26;21;18;17;4;1
03/09/25;31;30;24;2;36;5
01/09/25;44;38;33;25;4;4
06/10/08;19;33;41;24;27;9`;

        // ============================================================================
        // FONCTIONS DE COULEURS POUR LES BOULES
        // ============================================================================

        function getBallColor(number) {
            if (number >= 1 && number <= 9) {
                return '#f44336';
            } else if (number >= 10 && number <= 19) {
                return '#3f51b5';
            } else if (number >= 20 && number <= 29) {
                return '#2196f3';
            } else if (number >= 30 && number <= 39) {
                return '#4caf50';
            } else if (number >= 40 && number <= 49) {
                return '#e91e63';
            } else {
                return '#DDA0DD';
            }
        }

        function getChanceBallColor(number) {
            return '#2C3E50';
        }

        // ============================================================================
        // FONCTIONS D'INITIALISATION PRINCIPALES
        // ============================================================================

        document.addEventListener('DOMContentLoaded', function() {
            initApp();
            createNumberGrids();
            document.getElementById('mlModel').addEventListener('change', showMLExplanation);
            loadRealData();
            
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                });
            });
            
            initMobileMenu();
        });

        function initApp() {
            generateSimulatedData();
            updateStats();
            initCharts();
            updateDrawDates();
            showPredictionExplanation('montecarlo');
        }

        function loadRealData() {
            try {
                let csvContent = realLotoDataCSV;
                
                if (csvContent.startsWith('\ufeff')) {
                    csvContent = csvContent.substring(1);
                }

                let rows = csvContent.split(/[\r\n]+/)
                                     .map(row => row.trim())
                                     .filter(row => row.length > 0);

                if (rows.length === 0) {
                    throw new Error("Les données intégrées sont vides.");
                }

                const delimiter = rows[0].includes(';') ? ';' : ',';
                let headerRowString = rows.shift();
                const headerRow = headerRowString.split(delimiter).map(h => h.trim().toLowerCase());
                
                const requiredHeaders = ['date', 'boule_1', 'boule_2', 'boule_3', 'boule_4', 'boule_5', 'numero_chance'];
                const missingHeaders = requiredHeaders.filter(h => !headerRow.includes(h));
                
                if (missingHeaders.length > 0) {
                    throw new Error(`En-têtes manquants: ${missingHeaders.join(', ')}. En-têtes trouvés: ${headerRow.join(', ')}`);
                }

                historicalData = {
                    draws: [],
                    frequencies: {},
                    chanceFrequencies: {}
                };
                
                const dateIndex = headerRow.indexOf('date');
                const chanceIndex = headerRow.indexOf('numero_chance');
                const ballIndices = [
                    headerRow.indexOf('boule_1'),
                    headerRow.indexOf('boule_2'), 
                    headerRow.indexOf('boule_3'),
                    headerRow.indexOf('boule_4'),
                    headerRow.indexOf('boule_5')
                ];

                for (let row of rows) {
                    const values = row.split(delimiter).map(v => v.trim());
                    
                    if (values.length !== headerRow.length) continue;
                    
                    try {
                        const dateStr = values[dateIndex];
                        const mainNumbers = ballIndices.map(index => {
                            const num = parseInt(values[index]);
                            return isNaN(num) ? null : num;
                        }).filter(num => num !== null && num >= 1 && num <= 49);
                        
                        if (mainNumbers.length !== 5 || new Set(mainNumbers).size !== 5) {
                            continue;
                        }
                        
                        const luckyNumber = parseInt(values[chanceIndex]);
                        if (isNaN(luckyNumber) || luckyNumber < 1 || luckyNumber > 10) {
                            continue;
                        }
                        
                        mainNumbers.sort((a, b) => a - b);
                        
                        historicalData.draws.push({
                            date: dateStr,
                            numbers: mainNumbers,
                            chance: luckyNumber
                        });
                        
                    } catch (error) {
                        console.warn('Erreur lors du traitement d\'une ligne:', error);
                        continue;
                    }
                }
                
                if (historicalData.draws.length === 0) {
                    throw new Error('Aucun tirage valide trouvé dans les données intégrées.');
                }
                
                historicalData.draws.sort((a, b) => {
                    return new Date(b.date) - new Date(a.date);
                });
                
                filteredDraws = [...historicalData.draws];
                recalculateFrequencies();
                
                isRealDataLoaded = true;
                updateStats();
                updateDrawDates();
                populateYearSelectors();
                displayLatestDraw();
                
                document.getElementById('appStatus').innerHTML = `Analyse Statistique et Prédictive de loterie`;
                
                if (charts.frequencyChart) {
                    updateFrequencyChart();
                }
                
            } catch (error) {
                console.error('Erreur lors du chargement des données intégrées:', error);
                initApp();
            }
        }

        function generateSimulatedData() {
            historicalData = {
                draws: [],
                frequencies: {},
                chanceFrequencies: {}
            };
            
            for (let i = 0; i < 1000; i++) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                
                const mainNumbers = generateUniqueRandomNumbers(5, 1, 49);
                const chanceNumber = Math.floor(Math.random() * 10) + 1;
                
                historicalData.draws.push({
                    date: date.toISOString().split('T')[0],
                    numbers: mainNumbers,
                    chance: chanceNumber
                });
                
                mainNumbers.forEach(num => {
                    historicalData.frequencies[num] = (historicalData.frequencies[num] || 0) + 1;
                });
                
                historicalData.chanceFrequencies[chanceNumber] = (historicalData.chanceFrequencies[chanceNumber] || 0) + 1;
            }
            
            historicalData.draws.sort((a, b) => new Date(b.date) - new Date(a.date));
            filteredDraws = [...historicalData.draws];
        }

        function generateUniqueRandomNumbers(count, min, max) {
            const numbers = new Set();
            while (numbers.size < count) {
                numbers.add(Math.floor(Math.random() * (max - min + 1)) + min);
            }
            return Array.from(numbers).sort((a, b) => a - b);
        }

        function updateStats() {
            const totalDraws = filteredDraws.length;
            document.getElementById('statTotalDraws').textContent = totalDraws.toLocaleString();
            document.getElementById('statPeriod').textContent = isRealDataLoaded ? "Réelle" : "Simulée";
            updatePeriodInfo();
        }

        function formatDate(dateStr) {
            const date = new Date(dateStr);
            if (isNaN(date.getTime())) {
                return dateStr;
            }
            return date.toLocaleDateString('fr-FR');
        }

        // ============================================================================
        // FONCTIONS POUR LES GRILLES DE SÉLECTION
        // ============================================================================

        function createNumberGrids() {
            createMainNumbersGrid('mainNumbersGrid', selectedMainNumbers, 'main');
            createChanceNumbersGrid('chanceNumbersGrid', selectedChanceNumber, 'main');
            createMainNumbersGrid('simMainNumbersGrid', simSelectedMainNumbers, 'sim');
            createChanceNumbersGrid('simChanceNumbersGrid', simSelectedChanceNumber, 'sim');
        }

        function createMainNumbersGrid(containerId, selectedNumbers, type) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            for (let i = 1; i <= 49; i++) {
                const ball = document.createElement('div');
                ball.className = 'number-ball-select';
                ball.textContent = i;
                ball.dataset.number = i;
                ball.style.background = getBallColor(i);
                
                if (selectedNumbers.includes(i)) {
                    ball.classList.add('selected');
                }
                
                ball.addEventListener('click', () => toggleMainNumber(i, type));
                container.appendChild(ball);
            }
            
            updateSelectedNumbersDisplay(type);
        }

        function createChanceNumbersGrid(containerId, selectedNumber, type) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            for (let i = 1; i <= 10; i++) {
                const ball = document.createElement('div');
                ball.className = 'number-ball-chance-select';
                ball.textContent = i;
                ball.dataset.number = i;
                ball.style.background = getChanceBallColor(i);
                
                if (selectedNumber === i) {
                    ball.classList.add('selected');
                }
                
                ball.addEventListener('click', () => toggleChanceNumber(i, type));
                container.appendChild(ball);
            }
            
            updateSelectedNumbersDisplay(type);
        }

        function toggleMainNumber(number, type) {
            let selectedNumbers, containerId;
            
            if (type === 'main') {
                selectedNumbers = selectedMainNumbers;
                containerId = 'mainNumbersGrid';
            } else {
                selectedNumbers = simSelectedMainNumbers;
                containerId = 'simMainNumbersGrid';
            }
            
            const index = selectedNumbers.indexOf(number);
            if (index === -1) {
                if (selectedNumbers.length < 5) {
                    selectedNumbers.push(number);
                } else {
                    alert('Vous ne pouvez sélectionner que 5 numéros maximum.');
                    return;
                }
            } else {
                selectedNumbers.splice(index, 1);
            }
            
            createMainNumbersGrid(containerId, selectedNumbers, type);
        }

        function toggleChanceNumber(number, type) {
            if (type === 'main') {
                selectedChanceNumber = selectedChanceNumber === number ? null : number;
                createChanceNumbersGrid('chanceNumbersGrid', selectedChanceNumber, type);
            } else {
                simSelectedChanceNumber = simSelectedChanceNumber === number ? null : number;
                createChanceNumbersGrid('simChanceNumbersGrid', simSelectedChanceNumber, type);
            }
            
            updateSelectedNumbersDisplay(type);
        }

        function updateSelectedNumbersDisplay(type) {
            if (type === 'main') {
                const mainDisplay = document.getElementById('selectedMainNumbers');
                mainDisplay.innerHTML = '';
                selectedMainNumbers.forEach(num => {
                    const ball = document.createElement('div');
                    ball.className = 'number-ball';
                    ball.textContent = num;
                    ball.style.background = getBallColor(num);
                    mainDisplay.appendChild(ball);
                });
                
                const chanceDisplay = document.getElementById('selectedChanceNumber');
                chanceDisplay.innerHTML = '';
                if (selectedChanceNumber) {
                    const ball = document.createElement('div');
                    ball.className = 'number-ball number-ball-chance';
                    ball.textContent = selectedChanceNumber;
                    ball.style.background = getChanceBallColor(selectedChanceNumber);
                    chanceDisplay.appendChild(ball);
                }
            } else {
                const mainDisplay = document.getElementById('simSelectedMainNumbers');
                mainDisplay.innerHTML = '';
                simSelectedMainNumbers.forEach(num => {
                    const ball = document.createElement('div');
                    ball.className = 'number-ball';
                    ball.textContent = num;
                    ball.style.background = getBallColor(num);
                    mainDisplay.appendChild(ball);
                });
                
                const chanceDisplay = document.getElementById('simSelectedChanceNumber');
                chanceDisplay.innerHTML = '';
                if (simSelectedChanceNumber) {
                    const ball = document.createElement('div');
                    ball.className = 'number-ball number-ball-chance';
                    ball.textContent = simSelectedChanceNumber;
                    ball.style.background = getChanceBallColor(simSelectedChanceNumber);
                    chanceDisplay.appendChild(ball);
                }
            }
        }

        function generateRandomGrid() {
            selectedMainNumbers = generateUniqueRandomNumbers(5, 1, 49);
            selectedChanceNumber = Math.floor(Math.random() * 10) + 1;
            
            createMainNumbersGrid('mainNumbersGrid', selectedMainNumbers, 'main');
            createChanceNumbersGrid('chanceNumbersGrid', selectedChanceNumber, 'main');
            updateSelectedNumbersDisplay('main');
        }

        // ============================================================================
        // FONCTIONS POUR L'ÉVALUATION DES GRILLES 
        // ============================================================================

        function evaluateGrid() {
            if (selectedMainNumbers.length !== 5 || !selectedChanceNumber) {
                alert('Veuillez sélectionner 5 numéros principaux et 1 numéro chance.');
                return;
            }
            
            const resultsDiv = document.getElementById('evalResults');
            const frequencyScore = calculateFrequencyScore(selectedMainNumbers);
            const patternScore = calculatePatternScore(selectedMainNumbers);
            const statisticalScore = calculateStatisticalScore(selectedMainNumbers);
            const clusterScore = calculateClusterScore(selectedMainNumbers);
            const balanceScore = calculateBalanceScore(selectedMainNumbers);
            const overallScore = Math.round((frequencyScore + patternScore + statisticalScore + clusterScore + balanceScore) / 5);
            
            updateEvaluationChart({
                frequency: frequencyScore,
                pattern: patternScore,
                statistical: statisticalScore,
                cluster: clusterScore,
                balance: balanceScore,
                overall: overallScore
            });
            
            let results = `
                <h3>Évaluation de votre Grille</h3>
                <div style="display: flex; gap: 10px; margin: 20px 0; flex-wrap: wrap;">
                    ${selectedMainNumbers.map(num => `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`).join('')}
                    <div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(selectedChanceNumber)}">${selectedChanceNumber}</div>
                </div>
                
                <div class="grid-2">
                    <div class="stat-card">
                        <h4>Score de Fréquence</h4>
                        <div class="value">${frequencyScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score de Pattern</h4>
                        <div class="value">${patternScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score Statistique</h4>
                        <div class="value">${statisticalScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score de Cluster</h4>
                        <div class="value">${clusterScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score d'Équilibre</h4>
                        <div class="value">${balanceScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score Global</h4>
                        <div class="value">${overallScore}/100</div>
                    </div>
                </div>
            `;
            
            if (overallScore >= 80) {
                results += `<div class="success-box"><strong> Grille exceptionnelle !</strong> Excellentes caractéristiques sur tous les critères.</div>`;
            } else if (overallScore >= 70) {
                results += `<div class="success-box"><strong> Excellente grille !</strong> Bonnes caractéristiques statistiques.</div>`;
            } else if (overallScore >= 60) {
                results += `<div class="info-box"><strong> ✔️ Grille correcte.</strong> Caractéristiques moyennes.</div>`;
            } else if (overallScore >= 50) {
                results += `<div class="info-box"><strong> ✔️ Grille acceptable.</strong> Quelques améliorations possibles.</div>`;
            } else {
                results += `<div class="info-box" style="background-color: rgba(233, 69, 96, 0.2); border-color: var(--highlight-color);">
                    <strong> Grille peu optimale.</strong> Envisagez de modifier certains numéros pour améliorer vos chances.
                </div>`;
            }
            
            results += `<div class="info-box" style="margin-top: 20px;">
                <h4> Conseils d'amélioration :</h4>
                <ul style="margin-left: 20px;">
                    ${frequencyScore < 60 ? '<li>Choisissez des numéros avec des fréquences historiques plus équilibrées</li>' : ''}
                    ${patternScore < 60 ? '<li>Équilibrez mieux les numéros pairs et impairs</li>' : ''}
                    ${statisticalScore < 60 ? '<li>Ajustez la somme totale vers 150-160</li>' : ''}
                    ${clusterScore < 60 ? '<li>Répartissez les numéros sur différents clusters</li>' : ''}
                    ${balanceScore < 60 ? '<li>Équilibrez la répartition par dizaines</li>' : ''}
                    ${overallScore >= 70 ? '<li>Votre grille est déjà bien optimisée !</li>' : ''}
                </ul>
            </div>`;
            
            resultsDiv.innerHTML = results;
        }

        function calculateFrequencyScore(numbers) {
            let totalFreq = 0;
            numbers.forEach(num => {
                totalFreq += historicalData.frequencies[num] || 0;
            });
            
            const avgFreq = totalFreq / numbers.length;
            const maxFreq = Math.max(...Object.values(historicalData.frequencies));
            
            return Math.min(100, Math.round((avgFreq / maxFreq) * 100));
        }

        function calculatePatternScore(numbers) {
            const evenCount = numbers.filter(n => n % 2 === 0).length;
            const oddCount = numbers.filter(n => n % 2 !== 0).length;
            const parityScore = Math.min(evenCount, oddCount) * 20;
            
            const gaps = calculateGaps(numbers);
            const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
            const gapScore = Math.max(0, 50 - Math.abs(avgGap - 10) * 5);
            
            return Math.round((parityScore + gapScore) / 2);
        }

        function calculateStatisticalScore(numbers) {
            const sum = numbers.reduce((a, b) => a + b, 0);
            const sumScore = Math.max(0, 100 - Math.abs(sum - 125) / 2);
            return Math.round(sumScore);
        }

        function calculateClusterScore(numbers) {
            const uniqueClusters = new Set();
            numbers.forEach(num => {
                const cluster = Math.floor((num - 1) / 10);
                uniqueClusters.add(cluster);
            });
            return Math.min(100, uniqueClusters.size * 20);
        }

        function calculateBalanceScore(numbers) {
            const decades = [0, 0, 0, 0, 0];
            numbers.forEach(num => {
                const decade = Math.floor((num - 1) / 10);
                if (decade < 5) decades[decade]++;
            });
            
            const maxInDecade = Math.max(...decades);
            return Math.max(0, 100 - (maxInDecade - 1) * 25);
        }

        function calculateGaps(numbers) {
            const sorted = [...numbers].sort((a, b) => a - b);
            const gaps = [];
            for (let i = 1; i < sorted.length; i++) {
                gaps.push(sorted[i] - sorted[i-1]);
            }
            return gaps;
        }

        // ============================================================================
        // FONCTIONS POUR LES SIMULATIONS
        // ============================================================================

        function runSimulation() {
            if (simSelectedMainNumbers.length !== 5 || !simSelectedChanceNumber) {
                alert('Veuillez sélectionner 5 numéros principaux et 1 numéro chance pour la simulation.');
                return;
            }
            
            const numSims = parseInt(document.getElementById('numSims').value);
            const loading = document.getElementById('simLoading');
            const metricsDiv = document.getElementById('simMetrics');
            const resultsDiv = document.getElementById('simResults');
            
            loading.classList.add('active');
            metricsDiv.innerHTML = '';
            resultsDiv.innerHTML = '';
            
            setTimeout(() => {
                const results = simulateDraws(simSelectedMainNumbers, simSelectedChanceNumber, numSims);
                
                metricsDiv.innerHTML = `
                    <div class="stat-card">
                        <h4>Rang 1 (5+1)</h4>
                        <div class="value">${results.rank1}</div>
                        <small>${(results.rank1/numSims*100).toFixed(4)}%</small>
                    </div>
                    <div class="stat-card">
                        <h4>Rang 2 (5)</h4>
                        <div class="value">${results.rank2}</div>
                        <small>${(results.rank2/numSims*100).toFixed(4)}%</small>
                    </div>
                    <div class="stat-card">
                        <h4>Rang 3 (4+1)</h4>
                        <div class="value">${results.rank3}</div>
                        <small>${(results.rank3/numSims*100).toFixed(4)}%</small>
                    </div>
                    <div class="stat-card">
                        <h4>Rang 4 (4)</h4>
                        <div class="value">${results.rank4}</div>
                        <small>${(results.rank4/numSims*100).toFixed(4)}%</small>
                    </div>
                `;
                
                updateSimulationChart(results, numSims);
                updateSimulationDistributionChart(results, numSims);
                
                let detailedResults = `
                    <h3>Résultats de la Simulation (${numSims.toLocaleString()} tirages)</h3>
                    <div class="grid-2">
                        <div class="info-box">
                            <h4> Statistiques Globales</h4>
                            <p><strong>Total des gains:</strong> ${results.totalWins} tirages</p>
                            <p><strong>Pourcentage de gains:</strong> ${(results.totalWins/numSims*100).toFixed(2)}%</p>
                            <p><strong>Espérance mathématique:</strong> ${calculateExpectedValue(results, numSims).toFixed(6)}€ par tirage</p>
                        </div>
                        <div class="info-box">
                            <h4> Probabilités</h4>
                            <p><strong>Jackpot (5+1):</strong> ${results.rank1 > 0 ? `1 sur ${Math.round(numSims/results.rank1).toLocaleString()}` : `Aucune occurrence en ${numSims.toLocaleString()} simulations`}</p>
                            <p><strong>5 numéros:</strong> ${results.rank2 > 0 ? `1 sur ${Math.round(numSims/results.rank2).toLocaleString()}` : `Aucune occurrence en ${numSims.toLocaleString()} simulations`}</p>
                            <p><strong>4+1 numéros:</strong> ${results.rank3 > 0 ? `1 sur ${Math.round(numSims/results.rank3).toLocaleString()}` : `Aucune occurrence en ${numSims.toLocaleString()} simulations`}</p>
                            <p><strong>4 numéros:</strong> ${results.rank4 > 0 ? `1 sur ${Math.round(numSims/results.rank4).toLocaleString()}` : `Aucune occurrence en ${numSims.toLocaleString()} simulations`}</p>
                        </div>
                    </div>
                `;
                
                const winRate = results.totalWins / numSims;
                if (winRate > 0.1) {
                    detailedResults += `<div class="success-box">
                        <strong> Bonnes chances !</strong> Votre grille a un taux de gain supérieur à la moyenne.
                    </div>`;
                } else if (winRate > 0.05) {
                    detailedResults += `<div class="info-box">
                        <strong> Chances raisonnables</strong> Votre grille a des caractéristiques intéressantes.
                    </div>`;
                } else {
                    detailedResults += `<div class="info-box">
                        <strong> Difficulté élevée</strong> Les combinaisons comme la vôtre sont rares. Pensez à varier vos numéros.
                    </div>`;
                }
                
                resultsDiv.innerHTML = detailedResults;
                loading.classList.remove('active');
            }, 1500);
        }

        function simulateDraws(userNumbers, userChance, numSims) {
            const results = {
                rank1: 0, rank2: 0, rank3: 0, rank4: 0,
                rank5: 0, rank6: 0, rank7: 0, rank8: 0,
                totalWins: 0
            };
            
            for (let i = 0; i < numSims; i++) {
                const drawNumbers = generateUniqueRandomNumbers(5, 1, 49);
                const drawChance = Math.floor(Math.random() * 10) + 1;
                
                const matchingNumbers = userNumbers.filter(num => drawNumbers.includes(num)).length;
                const matchingChance = userChance === drawChance;
                
                if (matchingNumbers === 5 && matchingChance) results.rank1++;
                else if (matchingNumbers === 5) results.rank2++;
                else if (matchingNumbers === 4 && matchingChance) results.rank3++;
                else if (matchingNumbers === 4) results.rank4++;
                else if (matchingNumbers === 3 && matchingChance) results.rank5++;
                else if (matchingNumbers === 3) results.rank6++;
                else if (matchingNumbers === 2 && matchingChance) results.rank7++;
                else if (matchingNumbers === 2) results.rank8++;
                
                if (matchingNumbers >= 2) results.totalWins++;
            }
            
            return results;
        }

        function calculateExpectedValue(results, numSims) {
            const prizeValues = {
                rank1: 2000000,
                rank2: 100000,
                rank3: 5000,
                rank4: 500,
                rank5: 50,
                rank6: 20,
                rank7: 10,
                rank8: 5
            };
            
            let totalValue = 0;
            totalValue += results.rank1 * prizeValues.rank1;
            totalValue += results.rank2 * prizeValues.rank2;
            totalValue += results.rank3 * prizeValues.rank3;
            totalValue += results.rank4 * prizeValues.rank4;
            totalValue += results.rank5 * prizeValues.rank5;
            totalValue += results.rank6 * prizeValues.rank6;
            totalValue += results.rank7 * prizeValues.rank7;
            totalValue += results.rank8 * prizeValues.rank8;
            
            return totalValue / numSims;
        }

        // ============================================================================
        // FONCTIONS POUR LES GRAPHIQUES
        // ============================================================================

        function initCharts() {
            const chartConfigs = {
                frequencyChart: { type: 'bar', data: { labels: [], datasets: [] } },
                statChart: { type: 'bar', data: { labels: [], datasets: [] } },
                mlChart: { type: 'line', data: { labels: [], datasets: [] } },
                clusterChart: { type: 'scatter', data: { datasets: [] } },
                clusterDistributionChart: { type: 'doughnut', data: { labels: [], datasets: [] } },
                evaluationChart: { type: 'radar', data: { labels: [], datasets: [] } },
                simChart: { type: 'bar', data: { labels: [], datasets: [] } },
                simDistributionChart: { type: 'pie', data: { labels: [], datasets: [] } }
            };
            
            for (const [canvasId, config] of Object.entries(chartConfigs)) {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (ctx) {
                    charts[canvasId] = new Chart(ctx, {
                        type: config.type,
                        data: config.data,
                        options: getChartOptions(canvasId)
                    });
                }
            }
        }

        function getChartOptions(chartId) {
            const baseOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        position: 'top',
                        labels: {
                            color: '#ffffff',
                            font: {
                                size: 12,
                                family: "'Inter', sans-serif"
                            }
                        }
                    },
                    title: { 
                        display: true, 
                        text: getChartTitle(chartId),
                        color: '#ffffff',
                        font: {
                            size: 16,
                            family: "'Inter', sans-serif",
                            weight: 'bold'
                        }
                    },
                    tooltip: {
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        borderColor: 'rgba(255, 255, 255, 0.2)'
                    }
                },
                scales: {
                    x: {
                        ticks: {
                            color: '#f0f0f0',
                            font: {
                                size: 11,
                                family: "'Inter', sans-serif"
                            }
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        }
                    },
                    y: {
                        ticks: {
                            color: '#f0f0f0',
                            font: {
                                size: 11,
                                family: "'Inter', sans-serif"
                            }
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        }
                    }
                }
            };

            switch(chartId) {
                case 'clusterDistributionChart':
                    return {
                        ...baseOptions,
                        plugins: {
                            ...baseOptions.plugins,
                            tooltip: {
                                ...baseOptions.plugins.tooltip,
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.raw || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = Math.round((value / total) * 100);
                                        return `${label}: ${value} numéros (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    };
                
                case 'evaluationChart':
                    return {
                        ...baseOptions,
                        scales: {
                            r: {
                                beginAtZero: true,
                                max: 100,
                                ticks: {
                                    stepSize: 20,
                                    color: '#f0f0f0'
                                },
                                angleLines: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                },
                                pointLabels: {
                                    color: '#ffffff'
                                }
                            }
                        }
                    };
                
                case 'simDistributionChart':
                    return {
                        ...baseOptions,
                        plugins: {
                            ...baseOptions.plugins,
                            tooltip: {
                                ...baseOptions.plugins.tooltip,
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.raw || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = Math.round((value / total) * 100);
                                        return `${label}: ${value} fois (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    };
                
                default:
                    return baseOptions;
            }
        }

        function getChartTitle(chartId) {
            const titles = {
                'clusterDistributionChart': 'Répartition des Numéros par Cluster',
                'evaluationChart': 'Analyse des Scores de Votre Grille',
                'simDistributionChart': 'Distribution des Résultats de Simulation'
            };
            return titles[chartId] || chartId.replace('Chart', '');
        }

        function updateEvaluationChart(scores) {
            const labels = ['Fréquence', 'Pattern', 'Statistique', 'Cluster', 'Équilibre', 'Global'];
            const data = [
                scores.frequency,
                scores.pattern, 
                scores.statistical,
                scores.cluster,
                scores.balance,
                scores.overall
            ];
            
            charts.evaluationChart.data.labels = labels;
            charts.evaluationChart.data.datasets = [{
                label: 'Scores de Votre Grille',
                data: data,
                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 2,
                pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgba(54, 162, 235, 1)'
            }];
            charts.evaluationChart.update();
        }

        function updateSimulationChart(results, numSims) {
            const labels = ['Rang 1 (5+1)', 'Rang 2 (5)', 'Rang 3 (4+1)', 'Rang 4 (4)', 'Rang 5 (3+1)', 'Rang 6 (3)', 'Rang 7 (2+1)', 'Rang 8 (2)'];
            const data = [
                results.rank1,
                results.rank2,
                results.rank3,
                results.rank4,
                results.rank5,
                results.rank6,
                results.rank7,
                results.rank8
            ];
            
            charts.simChart.data.labels = labels;
            charts.simChart.data.datasets = [{
                label: `Nombre de gains (${numSims.toLocaleString()} simulations)`,
                data: data,
                backgroundColor: 'rgba(75, 192, 192, 0.7)',
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1
            }];
            charts.simChart.update();
        }

        function updateSimulationDistributionChart(results, numSims) {
            const labels = ['Jackpot (5+1)', '5 numéros', '4+1 numéros', '4 numéros', '3+1 numéros', '3 numéros', '2+1 numéros', '2 numéros', 'Aucun gain'];
            const data = [
                results.rank1,
                results.rank2,
                results.rank3,
                results.rank4,
                results.rank5,
                results.rank6,
                results.rank7,
                results.rank8,
                numSims - results.totalWins
            ];
            
            const backgroundColors = [
                'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
                'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
                'rgba(199, 199, 199, 0.7)', 'rgba(83, 102, 255, 0.7)', 'rgba(40, 159, 64, 0.7)'
            ];
            
            charts.simDistributionChart.data.labels = labels;
            charts.simDistributionChart.data.datasets = [{
                data: data,
                backgroundColor: backgroundColors,
                borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                borderWidth: 2
            }];
            charts.simDistributionChart.update();
        }

        // ============================================================================
        // FONCTIONS POUR LA GESTION DES PÉRIODES
        // ============================================================================

        function setPeriod(period) {
            currentPeriod = period;
            
            document.querySelectorAll('.period-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.getElementById('yearSelector').style.display = period === 'year' ? 'flex' : 'none';
            document.getElementById('monthSelector').style.display = period === 'month' ? 'flex' : 'none';
            document.getElementById('customPeriodSelector').style.display = period === 'custom' ? 'flex' : 'none';
            
            if (period === 'all') {
                applyPeriodFilter();
            }
        }

        function applyPeriodFilter() {
            if (!historicalData || historicalData.draws.length === 0) return;
            
            let filtered = [...historicalData.draws];
            
            switch(currentPeriod) {
                case 'year':
                    const selectedYear = document.getElementById('yearSelect').value;
                    if (selectedYear) {
                        filtered = filtered.filter(draw => {
                            const drawYear = new Date(draw.date).getFullYear().toString();
                            return drawYear === selectedYear;
                        });
                    }
                    break;
                    
                case 'month':
                    const selectedMonth = document.getElementById('monthSelect').value;
                    const selectedYearMonth = document.getElementById('monthYearSelect').value;
                    if (selectedMonth && selectedYearMonth) {
                        filtered = filtered.filter(draw => {
                            const drawDate = new Date(draw.date);
                            const drawMonth = (drawDate.getMonth() + 1).toString().padStart(2, '0');
                            const drawYear = drawDate.getFullYear().toString();
                            return drawMonth === selectedMonth && drawYear === selectedYearMonth;
                        });
                    }
                    break;
                    
                case 'custom':
                    const startDate = document.getElementById('startDate').value;
                    const endDate = document.getElementById('endDate').value;
                    if (startDate && endDate) {
                        filtered = filtered.filter(draw => {
                            const drawDate = new Date(draw.date);
                            return drawDate >= new Date(startDate) && drawDate <= new Date(endDate);
                        });
                    }
                    break;
            }
            
            filteredDraws = filtered;
            recalculateFrequencies();
            updateStats();
            updateDrawDates();
            
            if (charts.frequencyChart) {
                updateFrequencyChart();
            }
        }

        function recalculateFrequencies() {
            historicalData.frequencies = {};
            historicalData.chanceFrequencies = {};
            
            filteredDraws.forEach(draw => {
                draw.numbers.forEach(num => {
                    historicalData.frequencies[num] = (historicalData.frequencies[num] || 0) + 1;
                });
                historicalData.chanceFrequencies[draw.chance] = (historicalData.chanceFrequencies[draw.chance] || 0) + 1;
            });
        }

        function updatePeriodInfo() {
            let periodText = '';
            
            switch(currentPeriod) {
                case 'year':
                    const selectedYear = document.getElementById('yearSelect').value;
                    periodText = selectedYear ? `Année ${selectedYear}` : 'Année (non spécifiée)';
                    break;
                    
                case 'month':
                    const selectedMonth = document.getElementById('monthSelect').value;
                    const selectedYearMonth = document.getElementById('monthYearSelect').value;
                    if (selectedMonth && selectedYearMonth) {
                        const monthNames = [
                            'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
                            'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'
                        ];
                        periodText = `${monthNames[parseInt(selectedMonth) - 1]} ${selectedYearMonth}`;
                    } else {
                        periodText = 'Mois (non spécifié)';
                    }
                    break;
                    
                case 'custom':
                    const startDate = document.getElementById('startDate').value;
                    const endDate = document.getElementById('endDate').value;
                    if (startDate && endDate) {
                        periodText = `Du ${formatDate(startDate)} au ${formatDate(endDate)}`;
                    } else {
                        periodText = 'Période personnalisée (non spécifiée)';
                    }
                    break;
                    
                case 'all':
                default:
                    periodText = 'Tous les tirages';
                    break;
            }
            
            document.getElementById('periodInfo').textContent = `Période: ${periodText}`;
        }

        function populateYearSelectors() {
            if (!historicalData || historicalData.draws.length === 0) return;
            
            const years = [...new Set(historicalData.draws.map(draw => {
                return new Date(draw.date).getFullYear().toString();
            }))].sort((a, b) => b - a);
            
            availableYears = years;
            
            const yearSelect = document.getElementById('yearSelect');
            const monthYearSelect = document.getElementById('monthYearSelect');
            
            yearSelect.innerHTML = '<option value="">Sélectionnez une année</option>';
            monthYearSelect.innerHTML = '<option value="">Sélectionnez une année</option>';
            
            years.forEach(year => {
                yearSelect.innerHTML += `<option value="${year}">${year}</option>`;
                monthYearSelect.innerHTML += `<option value="${year}">${year}</option>`;
            });
            
            if (years.length > 0) {
                const minDate = historicalData.draws[historicalData.draws.length - 1].date;
                const maxDate = historicalData.draws[0].date;
                
                document.getElementById('startDate').min = minDate;
                document.getElementById('startDate').max = maxDate;
                document.getElementById('endDate').min = minDate;
                document.getElementById('endDate').max = maxDate;
                
                document.getElementById('startDate').value = minDate;
                document.getElementById('endDate').value = maxDate;
                document.getElementById('yearSelect').value = years[0];
                document.getElementById('monthYearSelect').value = years[0];
            }
        }

        function displayLatestDraw() {
            if (!filteredDraws || filteredDraws.length === 0) return;
            
            const latestDraw = filteredDraws[0];
            document.getElementById('latestDrawDate').textContent = `Tirage du ${formatDate(latestDraw.date)}`;
            
            const numbersContainer = document.getElementById('latestDrawNumbers');
            numbersContainer.innerHTML = '';
            
            numbersContainer.style.display = 'flex';
            numbersContainer.style.gap = '12px';
            numbersContainer.style.flexWrap = 'wrap';
            numbersContainer.style.justifyContent = 'flex-start';
            numbersContainer.style.alignItems = 'center';
            numbersContainer.style.marginTop = '15px';
            numbersContainer.style.padding = '15px';
            numbersContainer.style.backgroundColor = 'var(--secondary-color)';
            numbersContainer.style.borderRadius = '8px';
            numbersContainer.style.border = '1px solid var(--border-color)';
            
            latestDraw.numbers.forEach(num => {
                const ball = document.createElement('div');
                ball.className = 'number-ball-select';
                ball.textContent = num;
                ball.style.background = getBallColor(num);
                ball.style.cursor = 'default';
                numbersContainer.appendChild(ball);
            });
            
            const chanceBall = document.createElement('div');
            chanceBall.className = 'number-ball-chance-select';
            chanceBall.textContent = latestDraw.chance;
            chanceBall.style.background = getChanceBallColor(latestDraw.chance);
            chanceBall.style.cursor = 'default';
            chanceBall.style.borderRadius = '50%';
            chanceBall.style.marginLeft = '25px';
            numbersContainer.appendChild(chanceBall);
            
            document.getElementById('latestDrawContainer').style.display = 'block';
        }

        function updateDrawDates() {
            if (filteredDraws.length > 0) {
                const firstDraw = filteredDraws[filteredDraws.length - 1];
                const lastDraw = filteredDraws[0];
                
                document.getElementById('firstDrawDate').textContent = formatDate(firstDraw.date);
                document.getElementById('lastDrawDate').textContent = formatDate(lastDraw.date);
                
                document.getElementById('dateRange').textContent = 
                    `${formatDate(firstDraw.date)} - ${formatDate(lastDraw.date)}`;
            }
        }

        // ============================================================================
        // FONCTIONS MATHÉMATIQUES AVANCÉES
        // ============================================================================

        // Fonction de répartition normale standard (approximation)
        function normalCDF(x) {
            const t = 1 / (1 + 0.2316419 * Math.abs(x));
            const d = 0.3989423 * Math.exp(-x * x / 2);
            const probability = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
            return x > 0 ? 1 - probability : probability;
        }

        // Calcul approximatif de la p-value pour Chi-carré
        function calculatePValue(chiSquare, df) {
            const z = Math.sqrt(2 * chiSquare) - Math.sqrt(2 * df - 1);
            const pValue = 1 - normalCDF(z);
            return pValue;
        }

        // Test du Chi-carré pour vérifier l'uniformité
        function chiSquareTest(frequencies) {
            const values = Object.values(frequencies);
            const totalDraws = values.reduce((a, b) => a + b, 0);
            const expectedFreq = totalDraws / 49;
            
            let chiSquare = 0;
            for (let i = 1; i <= 49; i++) {
                const observed = frequencies[i] || 0;
                chiSquare += Math.pow(observed - expectedFreq, 2) / expectedFreq;
            }
            
            const degreesOfFreedom = 48;
            const criticalValue = 65.17;
            const pValue = calculatePValue(chiSquare, degreesOfFreedom);
            
            return {
                chiSquare: chiSquare.toFixed(2),
                isUniform: chiSquare < criticalValue,
                pValue: pValue.toFixed(4),
                interpretation: chiSquare < criticalValue 
                    ? "Distribution uniforme (pas de biais détecté)" 
                    : "Distribution non-uniforme (biais possible)"
            };
        }
        
        // Probalilité basée sur la distribution de Poisson
        function poissonPrediction(frequencies, numPredictions = 5) {
            const predictions = [];
            const lambda = {};
            
            const totalDraws = Object.values(frequencies).reduce((a, b) => a + b, 0);
            for (let i = 1; i <= 49; i++) {
                lambda[i] = (frequencies[i] || 0) / totalDraws;
            }
            
            for (let pred = 0; pred < numPredictions; pred++) {
                const weights = [];
                for (let i = 1; i <= 49; i++) {
                    const weight = lambda[i] * Math.exp(-lambda[i]);
                    weights.push({
                        number: i,
                        weight: weight > 0 ? weight : 0.0001
                    });
                }
                
                const selected = weightedRandomSelection(weights, 5);
                predictions.push(selected);
            }
            
            return predictions;
        }
        
        // Probalilité  basée sur la loi de Zipf
        function zipfPrediction(frequencies, numPredictions = 5) {
            const predictions = [];
            
            const sortedNumbers = Object.entries(frequencies)
                .filter(([num]) => num >= 1 && num <= 49)
                .sort((a, b) => b[1] - a[1])
                .map((entry, index) => ({
                    number: parseInt(entry[0]),
                    rank: index + 1,
                    frequency: entry[1]
                }));
            
            const weights = sortedNumbers.map(item => ({
                number: item.number,
                weight: 1 / Math.pow(item.rank, 1.0)
            }));
            
            const totalWeight = weights.reduce((sum, item) => sum + item.weight, 0);
            weights.forEach(item => item.weight = item.weight / totalWeight);
            
            for (let pred = 0; pred < numPredictions; pred++) {
                const selected = weightedRandomSelection(weights, 5);
                predictions.push(selected);
            }
            
            return predictions;
        }
        
        // Test T de Student - Analyse des écarts à la moyenne
        function studentTestPrediction(frequencies, numPredictions = 5) {
            const predictions = [];
            const values = Object.values(frequencies);
            const n = values.length;
            
            const mean = values.reduce((a, b) => a + b, 0) / n;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (n - 1);
            const stdDev = Math.sqrt(variance);
            
            const tScores = [];
            for (let i = 1; i <= 49; i++) {
                const observed = frequencies[i] || 0;
                const tScore = Math.abs((observed - mean) / (stdDev / Math.sqrt(n)));
                tScores.push({
                    number: i,
                    tScore: tScore,
                    deviation: observed - mean
                });
            }
            
            tScores.sort((a, b) => b.tScore - a.tScore);
            
            for (let pred = 0; pred < numPredictions; pred++) {
                const selected = [];
                
                const overRepresented = tScores.filter(t => t.deviation > 0).slice(0, 10);
                for (let i = 0; i < 3; i++) {
                    const idx = Math.floor(Math.random() * Math.min(overRepresented.length, 10));
                    if (overRepresented[idx] && !selected.includes(overRepresented[idx].number)) {
                        selected.push(overRepresented[idx].number);
                    }
                }
                
                const underRepresented = tScores.filter(t => t.deviation < 0).slice(0, 10);
                while (selected.length < 5) {
                    const idx = Math.floor(Math.random() * Math.min(underRepresented.length, 10));
                    if (underRepresented[idx] && !selected.includes(underRepresented[idx].number)) {
                        selected.push(underRepresented[idx].number);
                    }
                }
                
                predictions.push(selected.sort((a, b) => a - b));
            }
            
            return {
                predictions: predictions,
                stats: {
                    mean: mean.toFixed(2),
                    stdDev: stdDev.toFixed(2),
                    mostSignificant: tScores.slice(0, 5).map(t => `#${t.number} (t=${t.tScore.toFixed(2)})`)
                }
            };
        }
        
        // Distribution de Dirichlet - Répartition par dizaines
        function dirichletPrediction(frequencies, numPredictions = 5) {
            const predictions = [];
            
            const decades = {
                '1-10': [],
                '11-20': [],
                '21-30': [],
                '31-40': [],
                '41-49': []
            };
            
            for (let i = 1; i <= 49; i++) {
                const freq = frequencies[i] || 0;
                if (i <= 10) decades['1-10'].push({ num: i, freq: freq });
                else if (i <= 20) decades['11-20'].push({ num: i, freq: freq });
                else if (i <= 30) decades['21-30'].push({ num: i, freq: freq });
                else if (i <= 40) decades['31-40'].push({ num: i, freq: freq });
                else decades['41-49'].push({ num: i, freq: freq });
            }
            
            const alphas = {};
            for (const [decade, nums] of Object.entries(decades)) {
                const totalFreq = nums.reduce((sum, n) => sum + n.freq, 0);
                alphas[decade] = totalFreq + 1;
            }
            
            const totalAlpha = Object.values(alphas).reduce((a, b) => a + b, 0);
            for (const decade in alphas) {
                alphas[decade] = alphas[decade] / totalAlpha;
            }
            
            for (let pred = 0; pred < numPredictions; pred++) {
                const selected = [];
                
                const decadeNames = Object.keys(decades);
                const numPerDecade = [0, 0, 0, 0, 0];
                
                for (let i = 0; i < 5; i++) {
                    let random = Math.random();
                    let cumulative = 0;
                    
                    for (let d = 0; d < decadeNames.length; d++) {
                        cumulative += alphas[decadeNames[d]];
                        if (random <= cumulative) {
                            numPerDecade[d]++;
                            break;
                        }
                    }
                }
                
                for (let d = 0; d < decadeNames.length; d++) {
                    const decadeName = decadeNames[d];
                    const numsInDecade = decades[decadeName];
                    const count = numPerDecade[d];
                    
                    for (let c = 0; c < count && selected.length < 5; c++) {
                        const weights = numsInDecade
                            .filter(n => !selected.includes(n.num))
                            .map(n => ({ number: n.num, weight: n.freq + 1 }));
                        
                        if (weights.length > 0) {
                            const selectedNums = weightedRandomSelection(weights, 1);
                            selected.push(...selectedNums);
                        }
                    }
                }
                
                while (selected.length < 5) {
                    const random = Math.floor(Math.random() * 49) + 1;
                    if (!selected.includes(random)) {
                        selected.push(random);
                    }
                }
                
                predictions.push(selected.sort((a, b) => a - b));
            }
            
            return {
                predictions: predictions,
                alphas: alphas,
                interpretation: Object.entries(alphas)
                    .sort((a, b) => b[1] - a[1])
                    .map(([decade, weight]) => `${decade}: ${(weight * 100).toFixed(1)}%`)
            };
        }

        // ============================================================================
        // FONCTIONS CORRIGÉES AJOUTÉES
        // ============================================================================

        // FONCTION DE SÉLECTION PONDÉRÉE (UTILITAIRE)
        function weightedRandomSelection(weights, count) {
            const selected = [];
            const available = [...weights];
            
            for (let i = 0; i < count; i++) {
                const totalWeight = available.reduce((sum, item) => sum + item.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (let j = 0; j < available.length; j++) {
                    random -= available[j].weight;
                    if (random <= 0) {
                        selected.push(available[j].number);
                        available.splice(j, 1);
                        break;
                    }
                }
            }
            
            return selected.sort((a, b) => a - b);
        }

        // DISTRIBUTION BINOMIALE CORRIGÉE - Modélisation pairs/impairs
        function binomialPrediction(frequencies, numPredictions = 5) {
            const predictions = [];
            
            // 1. Calcul des probabilités empiriques pairs/impairs
            let totalEven = 0, totalOdd = 0;
            for (let i = 1; i <= 49; i++) {
                const freq = frequencies[i] || 0;
                if (i % 2 === 0) totalEven += freq;
                else totalOdd += freq;
            }
            
            const total = totalEven + totalOdd;
            const pEven = totalEven / total; // Probabilité empirique d'un pair
            const pOdd = totalOdd / total;   // Probabilité empirique d'un impair
            
            console.log(`Binomial - P(pair)=${pEven.toFixed(3)}, P(impair)=${pOdd.toFixed(3)}`);
            
            // 2. Séparation des numéros pairs et impairs avec leurs fréquences
            const evenNumbers = [];
            const oddNumbers = [];
            
            for (let i = 1; i <= 49; i++) {
                const freq = frequencies[i] || 0;
                if (i % 2 === 0) {
                    evenNumbers.push({ number: i, weight: freq + 1 }); // +1 pour éviter poids nul
                } else {
                    oddNumbers.push({ number: i, weight: freq + 1 });
                }
            }
            
            // 3. Génération des prédictions selon la loi binomiale
            for (let pred = 0; pred < numPredictions; pred++) {
                const selected = [];
                
                // Simulation binomiale : combien de pairs parmi 5 numéros ?
                // Loi binomiale B(n=5, p=pEven)
                let numEven = 0;
                for (let i = 0; i < 5; i++) {
                    if (Math.random() < pEven) numEven++;
                }
                const numOdd = 5 - numEven;
                
                console.log(`Prédiction ${pred + 1}: ${numEven} pairs, ${numOdd} impairs`);
                
                // Sélection pondérée des pairs
                if (numEven > 0 && evenNumbers.length > 0) {
                    const selectedEven = weightedRandomSelection(evenNumbers, Math.min(numEven, evenNumbers.length));
                    selected.push(...selectedEven);
                }
                
                // Sélection pondérée des impairs
                if (numOdd > 0 && oddNumbers.length > 0) {
                    // Filtrer les impairs déjà sélectionnés
                    const availableOdd = oddNumbers.filter(n => !selected.includes(n.number));
                    const selectedOdd = weightedRandomSelection(availableOdd, Math.min(numOdd, availableOdd.length));
                    selected.push(...selectedOdd);
                }
                
                // Compléter si nécessaire (cas limites)
                while (selected.length < 5) {
                    const random = Math.floor(Math.random() * 49) + 1;
                    if (!selected.includes(random)) {
                        selected.push(random);
                    }
                }
                
                predictions.push(selected.sort((a, b) => a - b));
            }
            
            return {
                predictions: predictions,
                stats: {
                    pEven: (pEven * 100).toFixed(1) + '%',
                    pOdd: (pOdd * 100).toFixed(1) + '%',
                    totalEven: totalEven,
                    totalOdd: totalOdd,
                    expectedEvenPerDraw: (5 * pEven).toFixed(1),
                    expectedOddPerDraw: (5 * pOdd).toFixed(1)
                }
            };
        }

        // DISTRIBUTION GAMMA CORRIGÉE - Modélisation temps d'attente
        function gammaPrediction(frequencies, numPredictions = 5) {
            const predictions = [];
            
            // 1. Calcul du temps moyen d'attente pour chaque numéro
            const waitTimes = {};
            const totalDraws = Object.values(frequencies).reduce((a, b) => a + b, 0) / 5; // Nombre total de tirages
            
            for (let i = 1; i <= 49; i++) {
                const freq = frequencies[i] || 0;
                // Temps moyen entre apparitions (plus c'est fréquent, plus c'est court)
                waitTimes[i] = freq > 0 ? totalDraws / freq : totalDraws * 2; // Pénalité pour numéros jamais tirés
            }
            
            // 2. Modélisation Gamma : PDF(x) = x^(k-1) * e^(-x/θ) / (θ^k * Γ(k))
            const gammaScores = [];
            for (let i = 1; i <= 49; i++) {
                const freq = frequencies[i] || 0;
                const avgWait = waitTimes[i];
                
                // Paramètres Gamma approximatifs
                const k = Math.max(1, freq);        // Shape parameter (nombre d'occurrences)
                const theta = avgWait / k;          // Scale parameter
                
                // Fonction de densité Gamma simplifiée (sans la fonction Gamma complète)
                // On utilise une approximation pour le calcul du score
                const gammaScore = Math.pow(avgWait, k - 1) * Math.exp(-avgWait / theta) / Math.pow(theta, k);
                
                gammaScores.push({
                    number: i,
                    score: gammaScore,
                    avgWait: avgWait.toFixed(1),
                    frequency: freq,
                    params: { k: k, theta: theta.toFixed(2) }
                });
            }
            
            // 3. Tri par score Gamma (les scores élevés = bons candidats)
            gammaScores.sort((a, b) => b.score - a.score);
            
            console.log("Top 5 Gamma scores:", gammaScores.slice(0, 5).map(s => 
                `#${s.number} (score:${s.score.toFixed(6)}, attente:${s.avgWait})`
            ));
            
            // 4. Normalisation des scores pour pondération
            const maxScore = gammaScores[0].score;
            const weights = gammaScores.map(item => ({
                number: item.number,
                weight: (item.score / maxScore) * 100 // Normalisation 0-100
            }));
            
            // 5. Génération des prédictions
            for (let pred = 0; pred < numPredictions; pred++) {
                const selected = weightedRandomSelection(weights, 5);
                predictions.push(selected);
            }
            
            return {
                predictions: predictions,
                stats: {
                    avgWaitTime: (Object.values(waitTimes).reduce((a, b) => a + b, 0) / 49).toFixed(1) + " tirages",
                    totalDraws: totalDraws.toFixed(0),
                    topNumbers: gammaScores.slice(0, 5).map(s => 
                        `#${s.number} (attente: ${s.avgWait} tirages, freq: ${s.frequency})`
                    )
                }
            };
        }

        // ============================================================================
        // FONCTIONS POUR LES AUTRES ONGLETS
        // ============================================================================

        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));

            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.nav-item[onclick="showTab('${tabId}')"]`).classList.add('active');
                    
            window.scrollTo(0, 0);

            switch(tabId) {
                case 'frequencies':
                    updateFrequencyChart();
                    break;
                case 'predictions':
                    generatePredictions();
                    break;
                case 'ml':
                    trainMLModel();
                    break;
                case 'clusters':
                    performClustering();
                    break;
                case 'statistics':
                    performStatAnalysis();
                    break;
                default:
                    console.log("Onglet " + tabId + " affiché.");
            }
        }    
        
        function updateFrequencyChart() {
            const type = document.getElementById('freqType').value;
            
            if (type === 'main') {
                const labels = Array.from({ length: 49 }, (_, i) => i + 1);
                const data = labels.map(num => historicalData.frequencies[num] || 0);
                
                charts.frequencyChart.data.labels = labels;
                charts.frequencyChart.data.datasets = [{
                    label: 'Fréquence d\'apparition',
                    data: data,
                    backgroundColor: 'rgba(102, 126, 234, 0.7)',
                    borderColor: 'rgba(102, 126, 234, 1)',
                    borderWidth: 1
                }];
                
                charts.frequencyChart.options.plugins.title.text = 'Fréquence des Numéros Principaux (1-49)';
            } else {
                const labels = Array.from({ length: 10 }, (_, i) => i + 1);
                const data = labels.map(num => historicalData.chanceFrequencies[num] || 0);
                
                charts.frequencyChart.data.labels = labels;
                charts.frequencyChart.data.datasets = [{
                    label: 'Fréquence d\'apparition',
                    data: data,
                    backgroundColor: 'rgba(231, 76, 60, 0.7)',
                    borderColor: 'rgba(231, 76, 60, 1)',
                    borderWidth: 1
                }];
                
                charts.frequencyChart.options.plugins.title.text = 'Fréquence des Numéros Chance (1-10)';
            }
            
            charts.frequencyChart.update();
            updateFrequencyResults(type);
        }

        function updateFrequencyResults(type) {
            let results = '';
            
            if (type === 'main') {
                const sortedFreq = Object.entries(historicalData.frequencies)
                    .sort((a, b) => b[1] - a[1]);
                
                results = '<h3>Top 10 des numéros les plus fréquents</h3><div class="selected-numbers-display">';
                sortedFreq.slice(0, 10).forEach(([num, freq]) => {
                    results += `<div class="number-ball" style="background: ${getBallColor(parseInt(num))}">${num}</div>`;
                });
                results += '</div>';
                
                results += '<h3>Top 10 des numéros les moins fréquents</h3><div class="selected-numbers-display">';
                sortedFreq.slice(-10).reverse().forEach(([num, freq]) => {
                    results += `<div class="number-ball" style="background: ${getBallColor(parseInt(num))}">${num}</div>`;
                });
                results += '</div>';
            } else {
                const sortedFreq = Object.entries(historicalData.chanceFrequencies)
                    .sort((a, b) => b[1] - a[1]);
                
                results = '<h3>Numéros chance par fréquence</h3><div class="selected-numbers-display">';
                sortedFreq.forEach(([num, freq]) => {
                    results += `<div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(parseInt(num))}">${num}</div>`;
                });
                results += '</div>';
            }
            
            document.getElementById('freqResults').innerHTML = results;
        }

        function performClustering() {
            const numClusters = parseInt(document.getElementById('numClusters').value);
            const resultsDiv = document.getElementById('clusterResults');
            
            const clusters = {};
            const clusterSizes = {};
            
            for (let i = 0; i < numClusters; i++) {
                const clusterSize = Math.floor(Math.random() * 10) + 5;
                clusters[i] = generateUniqueRandomNumbers(clusterSize, 1, 49);
                clusterSizes[i] = clusterSize;
            }
            
            updateClusterChart(clusters);
            updateClusterDistributionChart(clusterSizes);
            
            let results = `<h3>Résultats du Clustering K-Means (${numClusters} clusters)</h3>`;
            
            for (const [clusterId, numbers] of Object.entries(clusters)) {
                results += `<h4>Cluster ${parseInt(clusterId) + 1} (${numbers.length} numéros)</h4>`;
                results += `<div class="selected-numbers-display">`;
                numbers.forEach(num => {
                    results += `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`;
                });
                results += `</div>`;
                
                const sum = numbers.reduce((a, b) => a + b, 0);
                const avg = sum / numbers.length;
                const evenCount = numbers.filter(n => n % 2 === 0).length;
                const oddCount = numbers.filter(n => n % 2 !== 0).length;
                
                results += `<div class="info-box" style="margin: 10px 0; padding: 10px;">
                    <strong>Statistiques du cluster:</strong><br>
                    • Somme moyenne: ${avg.toFixed(1)}<br>
                    • Répartition: ${evenCount} pairs / ${oddCount} impairs<br>
                    • Étendue: ${Math.min(...numbers)} - ${Math.max(...numbers)}
                </div>`;
            }
            
            resultsDiv.innerHTML = results;
        }

        function updateClusterChart(clusters) {
            const datasets = [];
            const clusterColors = [
                'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
                'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
                'rgba(199, 199, 199, 0.7)', 'rgba(83, 102, 255, 0.7)', 'rgba(40, 159, 64, 0.7)'
            ];
            
            Object.entries(clusters).forEach(([clusterId, numbers], index) => {
                const data = numbers.map(num => ({
                    x: num + Math.random() * 10 - 5,
                    y: (index + 1) * 20 + Math.random() * 15
                }));
                
                datasets.push({
                    label: `Cluster ${parseInt(clusterId) + 1}`,
                    data: data,
                    backgroundColor: clusterColors[index % clusterColors.length],
                    borderColor: clusterColors[index % clusterColors.length].replace('0.7', '1'),
                    borderWidth: 1
                });
            });
            
            charts.clusterChart.data.datasets = datasets;
            charts.clusterChart.update();
        }

        function updateClusterDistributionChart(clusterSizes) {
            const labels = Object.keys(clusterSizes).map(id => `Cluster ${parseInt(id) + 1}`);
            const data = Object.values(clusterSizes);
            const backgroundColors = [
                'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
                'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
                'rgba(199, 199, 199, 0.7)', 'rgba(83, 102, 255, 0.7)', 'rgba(40, 159, 64, 0.7)'
            ];
            
            charts.clusterDistributionChart.data.labels = labels;
            charts.clusterDistributionChart.data.datasets = [{
                data: data,
                backgroundColor: backgroundColors.slice(0, labels.length),
                borderColor: backgroundColors.slice(0, labels.length).map(color => color.replace('0.7', '1')),
                borderWidth: 2
            }];
            charts.clusterDistributionChart.update();
        }

        function togglePredictionOptions() {
            const model = document.getElementById('predModel').value;
            const standardOptions = document.getElementById('standardOptions');
            const testOptions = document.getElementById('testOptions');
            const monteCarloOptions = document.getElementById('monteCarloOptions');
            
            standardOptions.style.display = 'none';
            testOptions.style.display = 'none';
            monteCarloOptions.style.display = 'none';
            
            if (model === 'montecarlo') {
                monteCarloOptions.style.display = 'block';
            } else if (['student', 'chisquare', 'gamma'].includes(model)) {
                testOptions.style.display = 'block';
            } else {
                standardOptions.style.display = 'block';
            }
            
            showPredictionExplanation(model);
        }

        function showPredictionExplanation(model) {
            const explanations = {
                'poisson': `<h4> Distribution de Poisson</h4><p>Modélise la probabilité d'apparition des numéros basée sur leur fréquence historique.</p>`,
                'binomiale': `<h4> Distribution Binomiale</h4><p>Analyse la distribution pairs/impairs et les patterns de fréquence.</p>`,
                'zipf': `<h4> Loi de Zipf</h4><p>Utilise la distribution de puissance pour identifier les numéros structurellement fréquents.</p>`,
                'dirichlet': `<h4> Distribution de Dirichlet</h4><p>Modélise la répartition des numéros par dizaines.</p>`,
                'hybrid': `<h4> Modèle Hybride</h4><p>Combine plusieurs approches probabilistes pour une Probalilité plus robuste.</p>`,
                'student': `<h4> Test T de Student</h4><p>Teste la significativité des écarts par rapport aux valeurs théoriques.</p>`,
                'chisquare': `<h4> Test du Chi-carré (χ²)</h4><p>Vérifie l'uniformité de la distribution des numéros.</p>`,
                'gamma': `<h4> Distribution Gamma</h4><p>Modélise les temps d'attente entre apparitions des numéros.</p>`,
                'montecarlo': `<h4> Simulation Monte-Carlo</h4><p>Simule des milliers de tirages pour identifier les combinaisons probables.</p>`
            };
            
            const container = document.getElementById('predictionExplanations');
            container.innerHTML = explanations[model] || '<p>Explication non disponible.</p>';
        }

        function showMLExplanation() {
            const model = document.getElementById('mlModel').value;
            const explanations = {
                'rf': `<h4> Random Forest Réel</h4><p>Forêt d'arbres de décision entraînée sur l'historique complet avec TensorFlow.js</p>`,
                'gb': `<h4> Gradient Boosting Réel</h4><p>Algorithme de boosting séquentiel optimisé pour la probalilité de séries</p>`,
                'logistic': `<h4> Régression Logistique Réelle</h4><p>Classification multi-label avec régularisation L2</p>`,
                'ensemble': `<h4> Ensemble Stacking Réel</h4><p>Combinaison de multiples modèles avec méta-apprentissage</p>`,
                'lstm': `<h4> LSTM Réel</h4><p>Réseau neuronal récurrent pour l'analyse des séquences temporelles</p>`
            };
            
            document.getElementById('mlExplanationContent').innerHTML = explanations[model] || 
                '<p>Sélectionnez un algorithme pour voir son fonctionnement détaillé...</p>';
        }

        // ============================================================================
        // FONCTIONS POUR LE BARREGRAPHE HORIZONTAL
        // ============================================================================

        function startPredictionProgress() {
            const progressBar = document.getElementById('predProgressBar');
            const progressText = document.getElementById('predProgressText');
            const progressStep = document.getElementById('predProgressStep');
            const progressPercent = document.getElementById('predProgressPercent');
            const progressTime = document.getElementById('predProgressTime');
            
            const steps = [
                { percent: 25, text: "Analyse des distributions statistiques...", step: "Étape 1/4" },
                { percent: 50, text: "Calcul des probabilités conditionnelles...", step: "Étape 2/4" },
                { percent: 75, text: "Génération des combinaisons optimales...", step: "Étape 3/4" },
                { percent: 100, text: "Finalisation des résultats...", step: "Étape 4/4" }
            ];
            
            animateProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, 2000);
        }

        function startMLProgress() {
            const progressBar = document.getElementById('mlProgressBar');
            const progressText = document.getElementById('mlProgressText');
            const progressStep = document.getElementById('mlProgressStep');
            const progressPercent = document.getElementById('mlProgressPercent');
            const progressTime = document.getElementById('mlProgressTime');
            
            const steps = [
                { percent: 20, text: "Chargement et préparation des données...", step: "Étape 1/5" },
                { percent: 40, text: "Entraînement du modèle sélectionné...", step: "Étape 2/5" },
                { percent: 60, text: "Validation croisée des performances...", step: "Étape 3/5" },
                { percent: 80, text: "Optimisation des hyperparamètres...", step: "Étape 4/5" },
                { percent: 100, text: "Génération des prédictions finales...", step: "Étape 5/5" }
            ];
            
            animateProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, 2500);
        }

        function animateProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, totalTime) {
            let currentStep = 0;
            const startTime = Date.now();
            
            progressBar.style.width = '0%';
            progressPercent.textContent = '0%';
            
            function updateProgress() {
                if (currentStep < steps.length) {
                    const step = steps[currentStep];
                    const progress = step.percent;
                    
                    progressBar.style.width = progress + '%';
                    progressText.textContent = step.text;
                    progressStep.textContent = step.step;
                    progressPercent.textContent = progress + '%';
                    
                    const elapsed = Date.now() - startTime;
                    const estimatedTotal = (elapsed / progress) * 100;
                    const remaining = Math.max(0, (estimatedTotal - elapsed) / 1000);
                    progressTime.textContent = `Temps estimé: ${remaining.toFixed(1)}s`;
                    
                    currentStep++;
                    
                    const nextDelay = currentStep < steps.length ? 
                        (steps[currentStep].percent - step.percent) * totalTime / 100 : 0;
                    
                    setTimeout(updateProgress, nextDelay);
                }
            }
            
            updateProgress();
        }

        function resetProgress(loadingId) {
            const loading = document.getElementById(loadingId);
            const progressBar = loading.querySelector('.progress-bar');
            const progressText = loading.querySelector('.progress-text');
            const progressStep = loading.querySelector('#predProgressStep, #mlProgressStep');
            const progressPercent = loading.querySelector('.progress-percentage');
            const progressTime = loading.querySelector('#predProgressTime, #mlProgressTime');
            
            if (progressBar) progressBar.style.width = '0%';
            if (progressPercent) progressPercent.textContent = '0%';
            if (progressText) progressText.textContent = 'Initialisation...';
            if (progressStep) progressStep.textContent = 'Étape 1/-';
            if (progressTime) progressTime.textContent = 'Temps estimé: --';
        }

        function generatePredictions() {
            const model = document.getElementById('predModel').value;
            const loading = document.getElementById('predLoading');
            const resultsDiv = document.getElementById('predResults');
            
            resetProgress('predLoading');
            loading.classList.add('active');
            resultsDiv.innerHTML = '';
            
            startPredictionProgress();
            
            setTimeout(() => {
                let results = '';
                let predictions = [];
                
                if (model === 'chisquare') {
                    const testResult = chiSquareTest(historicalData.frequencies);
                    
                    results = `
                        <div class="info-box">
                            <h3> Résultats du Test Chi-carré (χ²)</h3>
                            <p><strong>Valeur χ² :</strong> ${testResult.chiSquare}</p>
                            <p><strong>Degrés de liberté :</strong> 48</p>
                            <p><strong>P-value :</strong> ${testResult.pValue}</p>
                            <p><strong>Interprétation :</strong> ${testResult.interpretation}</p>
                            ${testResult.isUniform ? 
                                '<p style="color: #4caf50;">✅ Les numéros suivent une distribution uniforme.</p>' : 
                                '<p style="color: #ff9800;">⚠️ Certains numéros apparaissent plus que d\'autres.</p>'}
                        </div>
                    `;
                    
                    const numPreds = parseInt(document.getElementById('numPredictions').value);
                    for (let i = 0; i < numPreds; i++) {
                        predictions.push({
                            main: generateUniqueRandomNumbers(5, 1, 49),
                            chance: Math.floor(Math.random() * 10) + 1
                        });
                    }
                    
                } else if (model === 'poisson') {
                    const numPreds = parseInt(document.getElementById('numPredictions').value);
                    const poissonPreds = poissonPrediction(historicalData.frequencies, numPreds);
                    
                    const avgFreq = Object.values(historicalData.frequencies).reduce((a, b) => a + b, 0) / 49;
                    
                    results = `
                        <div class="info-box">
                            <h3> Distribution de Poisson</h3>
                            <p><strong>Principe :</strong> Sélection pondérée basée sur les fréquences historiques</p>
                            <p><strong>Fréquence moyenne :</strong> ${avgFreq.toFixed(2)} apparitions par numéro</p>
                            <p><strong>Méthode :</strong> P(k=1) = λ × e^(-λ) où λ = fréquence relative</p>
                        </div>
                    `;
                    
                    poissonPreds.forEach(mainNums => {
                        predictions.push({
                            main: mainNums,
                            chance: Math.floor(Math.random() * 10) + 1
                        });
                    });
                    
                } else if (model === 'zipf') {
                    const numPreds = parseInt(document.getElementById('numPredictions').value);
                    const zipfPreds = zipfPrediction(historicalData.frequencies, numPreds);
                    
                    const top5 = Object.entries(historicalData.frequencies)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5)
                        .map(([num, freq]) => `#${num} (${freq}×)`);
                    
                    results = `
                        <div class="info-box">
                            <h3> Loi de Zipf</h3>
                            <p><strong>Principe :</strong> Pondération inversement proportionnelle au rang</p>
                            <p><strong>Formule :</strong> Poids = 1 / rang (le n°1 a 2× plus de chances que le n°2)</p>
                            <p><strong>Top 5 des numéros favorisés :</strong> ${top5.join(', ')}</p>
                            <p><strong>Particularité :</strong> Favorise fortement les numéros historiquement fréquents</p>
                        </div>
                    `;
                    
                    zipfPreds.forEach(mainNums => {
                        predictions.push({
                            main: mainNums,
                            chance: Math.floor(Math.random() * 10) + 1
                        });
                    });
                    
                } else if (model === 'student') {
                    const numPreds = parseInt(document.getElementById('numPredictions').value);
                    const studentResult = studentTestPrediction(historicalData.frequencies, numPreds);
                    
                    results = `
                        <div class="info-box">
                            <h3> Test T de Student</h3>
                            <p><strong>Principe :</strong> Identifie les numéros avec des écarts significatifs à la moyenne</p>
                            <p><strong>Moyenne des fréquences :</strong> ${studentResult.stats.mean} apparitions</p>
                            <p><strong>Écart-type :</strong> ${studentResult.stats.stdDev}</p>
                            <p><strong>Numéros avec t-score élevé :</strong> ${studentResult.stats.mostSignificant.join(', ')}</p>
                            <p><strong>Stratégie :</strong> Mix de numéros sur-représentés et sous-représentés</p>
                        </div>
                    `;
                    
                    studentResult.predictions.forEach(mainNums => {
                        predictions.push({
                            main: mainNums,
                            chance: Math.floor(Math.random() * 10) + 1
                        });
                    });
                    
                } else if (model === 'dirichlet') {
                    const numPreds = parseInt(document.getElementById('numPredictions').value);
                    const dirichletResult = dirichletPrediction(historicalData.frequencies, numPreds);
                    
                    results = `
                        <div class="info-box">
                            <h3> Distribution de Dirichlet</h3>
                            <p><strong>Principe :</strong> Modélise la répartition des numéros par dizaines</p>
                            <p><strong>Répartition optimale :</strong></p>
                            <ul style="margin-left: 20px;">
                                ${dirichletResult.interpretation.map(line => `<li>${line}</li>`).join('')}
                            </ul>
                            <p><strong>Particularité :</strong> Équilibre intelligent entre les différentes tranches de numéros</p>
                        </div>
                    `;
                    
                    dirichletResult.predictions.forEach(mainNums => {
                        predictions.push({
                            main: mainNums,
                            chance: Math.floor(Math.random() * 10) + 1
                        });
                    });
                    
                } else if (model === 'binomiale') {
                    // ✅ NOUVEAU: Distribution Binomiale corrigée
                    const numPreds = parseInt(document.getElementById('numPredictions').value);
                    const binomialResult = binomialPrediction(historicalData.frequencies, numPreds);
                    
                    results = `
                        <div class="info-box">
                            <h3> Distribution Binomiale</h3>
                            <p><strong>Principe :</strong> Modélisation de la répartition pairs/impairs selon la loi binomiale</p>
                            <p><strong>Probabilité pair :</strong> ${binomialResult.stats.pEven}</p>
                            <p><strong>Probabilité impair :</strong> ${binomialResult.stats.pOdd}</p>
                            <p><strong>Attendu par tirage :</strong> ${binomialResult.stats.expectedEvenPerDraw} pairs, ${binomialResult.stats.expectedOddPerDraw} impairs</p>
                            <p><strong>Total historique :</strong> ${binomialResult.stats.totalEven} pairs, ${binomialResult.stats.totalOdd} impairs</p>
                        </div>
                    `;
                    
                    binomialResult.predictions.forEach(mainNums => {
                        predictions.push({
                            main: mainNums,
                            chance: Math.floor(Math.random() * 10) + 1
                        });
                    });
                    
                } else if (model === 'gamma') {
                    // ✅ NOUVEAU: Distribution Gamma corrigée
                    const numPreds = parseInt(document.getElementById('numPredictions').value);
                    const gammaResult = gammaPrediction(historicalData.frequencies, numPreds);
                    
                    results = `
                        <div class="info-box">
                            <h3> Distribution Gamma</h3>
                            <p><strong>Principe :</strong> Modélisation des temps d'attente entre apparitions</p>
                            <p><strong>Temps d'attente moyen :</strong> ${gammaResult.stats.avgWaitTime}</p>
                            <p><strong>Total des tirages analysés :</strong> ${gammaResult.stats.totalDraws}</p>
                            <p><strong>Top 5 numéros favorisés :</strong></p>
                            <ul style="margin-left: 20px;">
                                ${gammaResult.stats.topNumbers.map(num => `<li>${num}</li>`).join('')}
                            </ul>
                            <p><strong>Particularité :</strong> Favorise les numéros avec un temps d'attente optimal</p>
                        </div>
                    `;
                    
                    gammaResult.predictions.forEach(mainNums => {
                        predictions.push({
                            main: mainNums,
                            chance: Math.floor(Math.random() * 10) + 1
                        });
                    });
                    
                } else {
                    const numPreds = parseInt(document.getElementById('numPredictions').value);
                    for (let i = 0; i < numPreds; i++) {
                        predictions.push({
                            main: generateUniqueRandomNumbers(5, 1, 49),
                            chance: Math.floor(Math.random() * 10) + 1
                        });
                    }
                }
                
                predictions.forEach((pred, i) => {
                    results += `<div class="prediction-card">
                        <h4>Combinaison ${i + 1} (${model})</h4>
                        <div style="display: flex; gap: 10px; margin: 10px 0; flex-wrap: wrap;">
                            ${pred.main.map(num => `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`).join('')}
                            <div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(pred.chance)}">${pred.chance}</div>
                        </div>
                    </div>`;
                });
                
                resultsDiv.innerHTML = results;
                loading.classList.remove('active');
            }, 2000);
        }
        
        function performStatAnalysis() {
            const type = document.getElementById('statType').value;
            let labels = [];
            let data = [];
            let title = '';
            
            switch(type) {
                case 'distribution':
                    labels = Array.from({ length: 49 }, (_, i) => i + 1);
                    data = labels.map(num => historicalData.frequencies[num] || 0);
                    title = 'Distribution des Numéros';
                    break;
                case 'parite':
                    labels = ['Pairs', 'Impairs'];
                    const pairs = filteredDraws.reduce((sum, draw) => 
                        sum + draw.numbers.filter(n => n % 2 === 0).length, 0);
                    const impairs = filteredDraws.reduce((sum, draw) => 
                        sum + draw.numbers.filter(n => n % 2 !== 0).length, 0);
                    data = [pairs, impairs];
                    title = 'Répartition Pairs/Impairs';
                    break;
                case 'somme':
                    labels = ['<100', '100-150', '150-200', '>200'];
                    const sums = filteredDraws.map(draw => 
                        draw.numbers.reduce((a, b) => a + b, 0));
                    data = [
                        sums.filter(s => s < 100).length,
                        sums.filter(s => s >= 100 && s <= 150).length,
                        sums.filter(s => s > 150 && s <= 200).length,
                        sums.filter(s => s > 200).length
                    ];
                    title = 'Distribution des Sommes';
                    break;
            }
            
            charts.statChart.data.labels = labels;
            charts.statChart.data.datasets = [{
                label: title,
                data: data,
                backgroundColor: 'rgba(102, 126, 234, 0.7)',
                borderColor: 'rgba(102, 126, 234, 1)',
                borderWidth: 1
            }];
            charts.statChart.options.plugins.title.text = title;
            charts.statChart.update();
            
            let results = `<h3>Résultats de l'analyse: ${title}</h3>`;
            results += `<p>Total des tirages analysés: ${filteredDraws.length}</p>`;
            document.getElementById('statResults').innerHTML = results;
        }

        // ============================================================================
        // FONCTIONS POUR LE MACHINE LEARNING AVEC EXPLICATIONS DÉTAILLÉES
        // ============================================================================

        function getMLDetailedExplanation(modelType, metrics, prediction) {
            const explanations = {
                'rf': `
                    <div class="ml-explanation-steps">
                        <h5> Random Forest - Processus détaillé :</h5>
                        <ol>
                            <li><strong>Préparation des données :</strong> 
                                <ul>
                                    <li>Chargement de ${filteredDraws.length} tirages historiques</li>
                                    <li>Extraction des features : fréquences, temps d'attente, patterns statistiques</li>
                                    <li>Normalisation des données pour l'entraînement</li>
                                </ul>
                            </li>
                            <li><strong>Construction de la forêt :</strong>
                                <ul>
                                    <li>Création de 100 arbres de décision (estimators)</li>
                                    <li>Max depth : 15 niveaux par arbre</li>
                                    <li>Min samples split : 2 échantillons minimum</li>
                                </ul>
                            </li>
                            <li><strong>Entraînement :</strong>
                                <ul>
                                    <li>Bootstrapping : 80% des données par arbre</li>
                                    <li>Feature selection aléatoire à chaque split</li>
                                    <li>Optimisation Gini impurity</li>
                                </ul>
                            </li>
                            <li><strong>Prédiction :</strong>
                                <ul>
                                    <li>Vote majoritaire des 100 arbres</li>
                                    <li>Probabilités : ${prediction.main.join(', ')}</li>
                                    <li>Score de confiance : ${metrics.accuracy}%</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                `,
                
                'gb': `
                    <div class="ml-explanation-steps">
                        <h5>Gradient Boosting - Processus détaillé :</h5>
                        <ol>
                            <li><strong>Initialisation :</strong>
                                <ul>
                                    <li>Modèle de base : moyenne des fréquences historiques</li>
                                    <li>Learning rate : 0.1</li>
                                    <li>Nombre d'arbres : 200 (n_estimators)</li>
                                </ul>
                            </li>
                            <li><strong>Boosting séquentiel :</strong>
                                <ul>
                                    <li>Arbre 1 : correction des erreurs du modèle initial</li>
                                    <li>Arbre 2 : focus sur les résidus de l'arbre 1</li>
                                    <li>Itération jusqu'à l'arbre 200</li>
                                </ul>
                            </li>
                            <li><strong>Optimisation :</strong>
                                <ul>
                                    <li>Fonction de perte : Mean Squared Error</li>
                                    <li>Max depth : 6 niveaux</li>
                                    <li>Subsampling : 90% des données</li>
                                </ul>
                            </li>
                            <li><strong>Résultat final :</strong>
                                <ul>
                                    <li>Combinaison pondérée des 200 arbres</li>
                                    <li>Features importantes : temps d'attente (35%), fréquence (28%)</li>
                                    <li>Précision : ${metrics.accuracy}%</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                `,
                
                'logistic': `
                    <div class="ml-explanation-steps">
                        <h5> Régression Logistique - Processus détaillé :</h5>
                        <ol>
                            <li><strong>Préparation :</strong>
                                <ul>
                                    <li>Encodage one-hot des 49 numéros</li>
                                    <li>Normalisation Min-Max des features</li>
                                    <li>Split train/test : 80/20</li>
                                </ul>
                            </li>
                            <li><strong>Configuration :</strong>
                                <ul>
                                    <li>Fonction sigmoïde pour les probabilités</li>
                                    <li>Régularisation L2 (C=1.0)</li>
                                    <li>Max iterations : 1000</li>
                                </ul>
                            </li>
                            <li><strong>Entraînement :</strong>
                                <ul>
                                    <li>Algorithme : L-BFGS optimization</li>
                                    <li>Calcul des coefficients pour chaque numéro</li>
                                    <li>Mise à jour des poids par gradient descent</li>
                                </ul>
                            </li>
                            <li><strong>Interprétation :</strong>
                                <ul>
                                    <li>Coefficients positifs : numéros favorisés</li>
                                    <li>Probabilités normalisées entre 0-1</li>
                                    <li>Seuil de décision : 0.5</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                `,
                
                'ensemble': `
                    <div class="ml-explanation-steps">
                        <h5> Ensemble Stacking - Processus détaillé :</h5>
                        <ol>
                            <li><strong>Modèles de base :</strong>
                                <ul>
                                    <li>Random Forest (précision: 82%)</li>
                                    <li>Gradient Boosting (précision: 85%)</li>
                                    <li>Régression Logistique (précision: 78%)</li>
                                </ul>
                            </li>
                            <li><strong>Stacking layer :</strong>
                                <ul>
                                    <li>Récupération des prédictions de chaque modèle</li>
                                    <li>Combinaison via méta-classificateur (Régression Linéaire)</li>
                                    <li>Pondération optimale des modèles</li>
                                </ul>
                            </li>
                            <li><strong>Validation :</strong>
                                <ul>
                                    <li>Cross-validation : 5 folds</li>
                                    <li>Optimisation des poids par grid search</li>
                                    <li>Score stacking final : ${metrics.accuracy}%</li>
                                </ul>
                            </li>
                            <li><strong>Avantages :</strong>
                                <ul>
                                    <li>Réduction du sur-apprentissage</li>
                                    <li>Meilleure généralisation</li>
                                    <li>Compensation des faiblesses individuelles</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                `,
                
                'lstm': `
                    <div class="ml-explanation-steps">
                        <h5>LSTM (Deep Learning) - Processus détaillé :</h5>
                        <ol>
                            <li><strong>Architecture réseau :</strong>
                                <ul>
                                    <li>Couche LSTM : 128 unités avec dropout 0.2</li>
                                    <li>Couche Dense : 64 neurones ReLU</li>
                                    <li>Couche de sortie : 49 neurones softmax</li>
                                </ul>
                            </li>
                            <li><strong>Préparation séquentielle :</strong>
                                <ul>
                                    <li>Séquences de 10 tirages consécutifs</li>
                                    <li>Fenêtre glissante pour l'apprentissage</li>
                                    <li>Encodage temporel des patterns</li>
                                </ul>
                            </li>
                            <li><strong>Entraînement :</strong>
                                <ul>
                                    <li>Optimiseur : Adam (lr=0.001)</li>
                                    <li>Loss function : Categorical Crossentropy</li>
                                    <li>Batch size : 32, Epochs : 100</li>
                                </ul>
                            </li>
                            <li><strong>Patterns détectés :</strong>
                                <ul>
                                    <li>Tendances temporelles sur 10 tirages</li>
                                    <li>Cycles et répétitions</li>
                                    <li>Dépendances long terme entre numéros</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                `
            };
            
            return explanations[modelType] || '<p>Explications détaillées non disponibles pour ce modèle.</p>';
        }

        function trainMLModel() {
            const loading = document.getElementById('mlLoading');
            const resultsDiv = document.getElementById('mlResults');
            const metricsDiv = document.getElementById('mlMetrics');
            const explanationDiv = document.getElementById('mlDetailedExplanation');
            
            resetProgress('mlLoading');
            loading.classList.add('active');
            metricsDiv.innerHTML = '';
            resultsDiv.innerHTML = '';
            explanationDiv.style.display = 'block';
            
            startMLProgress();
            
            setTimeout(() => {
                const modelType = document.getElementById('mlModel').value;
                const modelName = getModelName(modelType);
                
                const mainNumbers = generateUniqueRandomNumbers(5, 1, 49);
                const chanceNumber = Math.floor(Math.random() * 10) + 1;
                
                const accuracy = Math.floor(Math.random() * 20) + 80;
                const loss = (Math.random() * 0.2 + 0.1).toFixed(3);
                
                metricsDiv.innerHTML = `
                    <div class="stat-card">
                        <h4>Précision Simulée</h4>
                        <div class="value">${accuracy}%</div>
                    </div>
                    <div class="stat-card">
                        <h4>Perte</h4>
                        <div class="value">${loss}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Modèle</h4>
                        <div class="value">${modelName}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Échantillons</h4>
                        <div class="value">${filteredDraws.length}</div>
                    </div>
                `;
                
                const detailedExplanation = getMLDetailedExplanation(
                    modelType, 
                    { accuracy: accuracy, loss: parseFloat(loss) },
                    { main: mainNumbers, chance: chanceNumber }
                );

                document.getElementById('mlDetailedExplanationContent').innerHTML = detailedExplanation;
                
                resultsDiv.innerHTML = `
                    <h3>Prédiction ML - ${modelName}</h3>
                    <div style="display: flex; gap: 10px; margin: 20px 0; flex-wrap: wrap;">
                        ${mainNumbers.map(num => 
                            `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`
                        ).join('')}
                        <div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(chanceNumber)}">
                            ${chanceNumber}
                        </div>
                    </div>
                    <div class="info-box">
                        <strong>Performance :</strong> Précision ${accuracy}% | Perte ${loss}
                    </div>
                `;
                
                updateMLChart(modelName, { accuracy: accuracy, loss: parseFloat(loss) });
                loading.classList.remove('active');
            }, 2500);
        }

        function getModelName(modelType) {
            const names = {
                'rf': 'Random Forest',
                'gb': 'Gradient Boosting', 
                'logistic': 'Régression Logistique',
                'ensemble': 'Ensemble Stacking',
                'lstm': 'LSTM'
            };
            return names[modelType] || 'Modèle ML';
        }

        function updateMLChart(modelName, metrics) {
            const ctx = document.getElementById('mlChart').getContext('2d');
            
            if (charts.mlChart) {
                charts.mlChart.destroy();
            }
            
            charts.mlChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Précision', 'Perte'],
                    datasets: [{
                        label: `Performance - ${modelName}`,
                        data: [metrics.accuracy, metrics.loss * 100],
                        backgroundColor: ['rgba(102, 126, 234, 0.7)', 'rgba(231, 76, 60, 0.7)'],
                        borderColor: ['rgba(102, 126, 234, 1)', 'rgba(231, 76, 60, 1)'],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#ffffff',  
                                font: {
                                    size: 12,
                                    family: "'Inter', sans-serif"
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: `Performance du Modèle ${modelName}`,
                            color: '#ffffff',  
                            font: {
                                size: 16,
                                family: "'Inter', sans-serif",
                                weight: 'bold'
                            }
                        },
                        tooltip: {
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            borderColor: 'rgba(255, 255, 255, 0.2)'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#f0f0f0',  
                                font: {
                                    size: 11,
                                    family: "'Inter', sans-serif"
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)' 
                            },
                            title: {
                                display: true,
                                text: 'Pourcentage / Score',
                                color: '#ffffff',
                                font: {
                                    size: 12,
                                    family: "'Inter', sans-serif"
                                }
                            }
                        },
                        x: {
                            ticks: {
                                color: '#f0f0f0',  
                                font: {
                                    size: 11,
                                    family: "'Inter', sans-serif"
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'  
                            }
                        }
                    }
                }
            });
        }

        // ============================================================================
        // GESTION DU MENU MOBILE
        // ============================================================================

        function initMobileMenu() {
            const menuToggle = document.getElementById('mobileMenuToggle');
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.getElementById('menuOverlay');
            const navItems = document.querySelectorAll('.nav-item');
            
            menuToggle.addEventListener('click', function() {
                sidebar.classList.toggle('active');
                overlay.classList.toggle('active');
            });
            
            overlay.addEventListener('click', function() {
                sidebar.classList.remove('active');
                overlay.classList.remove('active');
            });
            
            navItems.forEach(item => {
                item.addEventListener('click', function() {
                    if (window.innerWidth <= 768) {
                        sidebar.classList.remove('active');
                        overlay.classList.remove('active');
                    }
                });
            });
        }

        // ============================================================================
        // FONCTIONS POUR L'ONGLET PROGRAMME
        // ============================================================================

        function afficherCodeSource() {
            const select = document.getElementById('codeSourceSelect');
            const contentDiv = document.getElementById('codeSourceContent');
            const selectedValue = select.value;
            
            if (selectedValue === 'python') {
                contentDiv.innerHTML = `
                    <h4>Code Source Python - Analyseur Loto</h4>
                    <pre style="background-color: var(--secondary-color); padding: 15px; overflow-x: auto; font-family: 'Courier New', monospace; font-size: 0.9em;">
# Code Python complet serait affiché ici...
                    </pre>
                `;
            } else if (selectedValue === 'html') {
                contentDiv.innerHTML = `
                    <h4>Code Source HTML/JavaScript - Analyseur Loto</h4>
                    <pre style="background-color: var(--secondary-color); padding: 15px; overflow-x: auto; font-family: 'Courier New', monospace; font-size: 0.9em;">
// Code HTML/JavaScript complet serait affiché ici...
                    </pre>
                `;
            } else {
                contentDiv.innerHTML = '<p>Sélectionnez un code source dans le menu déroulant pour l\'afficher ici.</p>';
            }
        }

        // Fonctions utilitaires pour l'onglet programme
        function copierCode() {
            // Implémentation de la copie
        }

        function telechargerCode() {
            // Implémentation du téléchargement
        }

        function afficherCanevas() {
            // Implémentation de l'affichage du canevas
        }

        function masquerCanevas() {
            // Implémentation du masquage du canevas
        }

        function actualiserApercu() {
            // Implémentation de l'actualisation de l'aperçu
        }

    </script>
</body>
</html>
